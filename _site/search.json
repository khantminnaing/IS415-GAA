[
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex01.html",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "",
    "text": "Human mobility, the spatial-temporal dynamics of human movements, serves as a critical reflection of societal patterns and human behaviors. With the advancement and pervasiveness of Information and Communication Technologies (ICT) in our daily life, especially smart phone, a large volume of data related to human mobility have been collected. These data provide valuable insights into understanding how individuals and populations move within and between different geographical locations. By using appropriate GIS analysis methods, these data can turn into valuable inisghts for predicting future mobility trrends and developing more efficient and sustainable strategies for managing urban mobility.\nIn this study, I will apply Spatial Point Patterns Analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore. In order to determine the geographical and spatio-temporal patterns of the Grab hailing services, I will develop traditional Kernel Density Estimation (KDE) and Temporal Network Kernel Density Estimation (TNKDE). KDE layers will help identify the areas with high concentration of Grab hailing services, providing insights into the demand and popularity of these services in different parts of Singapore. TNKDE, on the other hand, will allow for analysis of how the distribution of Grab hailing services changes over time, revealing temporal patterns and trends in their usage. These spatial and spatio-temporal analyses will contribute to a better understanding of the dynamics and effectiveness of Grab’s mobility services in Singapore."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#introduction",
    "href": "Take-home_Ex/Take-home_Ex01.html#introduction",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "",
    "text": "Human mobility, the spatial-temporal dynamics of human movements, serves as a critical reflection of societal patterns and human behaviors. With the advancement and pervasiveness of Information and Communication Technologies (ICT) in our daily life, especially smart phone, a large volume of data related to human mobility have been collected. These data provide valuable insights into understanding how individuals and populations move within and between different geographical locations. By using appropriate GIS analysis methods, these data can turn into valuable inisghts for predicting future mobility trrends and developing more efficient and sustainable strategies for managing urban mobility.\nIn this study, I will apply Spatial Point Patterns Analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore. In order to determine the geographical and spatio-temporal patterns of the Grab hailing services, I will develop traditional Kernel Density Estimation (KDE) and Temporal Network Kernel Density Estimation (TNKDE). KDE layers will help identify the areas with high concentration of Grab hailing services, providing insights into the demand and popularity of these services in different parts of Singapore. TNKDE, on the other hand, will allow for analysis of how the distribution of Grab hailing services changes over time, revealing temporal patterns and trends in their usage. These spatial and spatio-temporal analyses will contribute to a better understanding of the dynamics and effectiveness of Grab’s mobility services in Singapore."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#literature-review-of-spatial-point-pattern-analysis",
    "href": "Take-home_Ex/Take-home_Ex01.html#literature-review-of-spatial-point-pattern-analysis",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "2.0 Literature Review of Spatial Point Pattern Analysis",
    "text": "2.0 Literature Review of Spatial Point Pattern Analysis\nSpatial point pattern analysis is concerned with description, statistical characterization, modeling and visulisation of point patterns over space and making inference about the process that could have generated an observed pattern (Boots & Getis, 1988 ,Rey et al., 2023; Pebesma & Bivand, 2023). According to this theory, empirical spatial distribution of points in our daily life are not controlled by sampling, but a result of an underlying geographically-continuous process (Rey et al., 2023). For example, an COVID-19 cluster did not happen by chance, but due to a spatial process of close-contact infection.\nWhen analysing real-world spatial points, it is important to analyse whether the observed spatial points are randomly distributed or patterned due to a process or interaction (Floch et al., 2018). In “complete random” distribution, points are located everywhere with the same probability and independently of each other. On the other hand, the spatial points can be clustered or dispersed due to an underlying point process. However, it is challenging to use heuristic observation and intuitive interpretation to detect whether a spatial point pattern exists (Baddeley et al., 2015; Floch et al., 2018). Hence, spatial point pattern analysis can be used to detect the spatial concentration or dispersion phenomena.\n\nWhen analysing and interpreting the properties of a point pattern, these properties can be categorized into two: (a) first-order properties and (b) second-order properties (Yuan et al., 2020; Gimond, 2023). First-order properties concern with the characteristics of individual point locations and their variations of their density across space (Gimond, 2023). Under this conception, observations vary from point to point due to changes in the underlying property. Second-order properties focus on not only individual points, but also the interactions between points and their influences on one another (Gimond, 2023). Under this conception, observations vary from place to place due to interaction effects between observations. First-order properties of point patterns are mostly addressed by density-based techniques, such as quadrat analysis and kernel density estimation, whereas, distance-based techniques, such nearest neighbour index and K-functions, are often used to analyse second-order properties since they take into account the distance between point pairs (Yuan et al., 2020; Gimond, 2023)."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#importing-packages",
    "href": "Take-home_Ex/Take-home_Ex01.html#importing-packages",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "3.0 Importing Packages",
    "text": "3.0 Importing Packages\nBefore we start the exercise, we will need to import necessary R packages first. We will use the following packages:\n\narrow : for reading and writing Apache Parquet files\nlubridate : for tackling with temporal data (dates and times)\nspatstat: A package for statistical analysis of spatial data, specifically Spatial Point Pattern Analysis. This package was provided by Baddeley, Turner and Ruback (2015) and gives a comprehensive list of functions to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.\nrgdal: Used to import geospatial data and output as spatial class objects from sp package\nraster : reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.\nmaptools, ggplot2, ggthemes, plotly: Packages used to plot interactive visualisations summary statistics and KDE layers\n\n\npacman::p_load(arrow,lubridate,tidyverse,tmap,sf,st,spatstat,patchwork,raster,spNetwork,gifski)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#importing-datasets-into-r-environment",
    "href": "Take-home_Ex/Take-home_Ex01.html#importing-datasets-into-r-environment",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "4.0 Importing Datasets into R Environment",
    "text": "4.0 Importing Datasets into R Environment\n\n4.1 Datasets\nIn this study, we will use Grab-Posisi dataset, which is a comprehensive GPS trajectory dataset for car-hailing services in Southeast Asia. Apart from the time and location of the object, GPS trajectories are also characterised by other parameters such as speed, the headed direction, the area and distance covered during its travel, and the travelled time. Thus, the trajectory patterns from users GPS data are a valuable source of information for a wide range of urban applications, such as solving transportation problems, traffic prediction, and developing reasonable urban planning.\nMoreover, we will also use OpenStreetMap dataset, which is an open-sourced geospatial dataset including shapefiles of important layers including road networks, forests, building footprints and many other points of interest.\nTo extract the Singapore boundary, we will use Master Plan 2019 Subzone Boundary (No Sea), provided by data.gov.sg.\n\n\n4.2 Importing Grab-Posisi Dataset\nEach trajectory in Grab-Posisi dataset is serialised in a file in Apache Parquet format. The Singapore portion of the dataset is packaged into a total of 10 Parquet files.\nFirstly, we will use read_parquet function from arrow package, which allows us to read Parquet files into R environment as a data frame (more specifically, a tibble).\n\ndf &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00000.snappy.parquet',as_data_frame = TRUE)\ndf1 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00001.snappy.parquet',as_data_frame = TRUE)\ndf2 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00002.snappy.parquet',as_data_frame = TRUE)\ndf3 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00003.snappy.parquet',as_data_frame = TRUE)\ndf4 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00004.snappy.parquet',as_data_frame = TRUE)\ndf5 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00005.snappy.parquet',as_data_frame = TRUE)\ndf6 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00006.snappy.parquet',as_data_frame = TRUE)\ndf7 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00007.snappy.parquet',as_data_frame = TRUE)\ndf8 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00008.snappy.parquet',as_data_frame = TRUE)\ndf9 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00009.snappy.parquet',as_data_frame = TRUE)\n\nTo consolidate all trajectory instances into a single dataframe, we’ll vertically bind all 10 imported dataframes using bind_rows() function from tidyverse package.\n\ndf_trajectories &lt;- bind_rows(df,df1,df2,df3,df4,df5,df6,df7,df8,df9)\n\nTo get a quick overview of the dataset, we’ll first check the number of trajectory instances using dim() function. Then, we’ll use head() function to quickly scan through the data columns and values\n\ndim(df_trajectories)\n\n[1] 30329685        9\n\nhead(df_trajectories)\n\n# A tibble: 6 × 9\n  trj_id driving_mode osname  pingtimestamp rawlat rawlng speed bearing accuracy\n  &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt;           &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 70014  car          android    1554943236   1.34   104.  18.9     248      3.9\n2 73573  car          android    1555582623   1.32   104.  17.7      44      4  \n3 75567  car          android    1555141026   1.33   104.  14.0      34      3.9\n4 1410   car          android    1555731693   1.26   104.  13.0     181      4  \n5 4354   car          android    1555584497   1.28   104.  14.8      93      3.9\n6 32630  car          android    1555395258   1.30   104.  23.2      73      3.9\n\n\nFrom the result above, we can see that the dataset includes a total of 30329685 trajectory instances, each with a total of 9 columns as follows:\n\n\n\nColumn Name\nData Type\nRemark\n\n\n\n\ntrj_id\nchr\nTrajectory ID\n\n\ndriving_mode\nchr\nMode of Driving\n\n\nosname\nchr\n\n\n\npingtimestamp\nint\nData Recording Timestamp\n\n\nrawlat\nnum\nLatitude Value (WGS-84)\n\n\nrawlng\nnum\nLongitude Value (WGS-84)\n\n\nspeed\nnum\nSpeed\n\n\nbearing\nint\nBearing\n\n\naccuracy\nnum\nAccuracy\n\n\n\nFrom the above table, it is seen that the pingtimestamp is recorded as int. We need to convert this data to proper datetime format to derive meaningful temporal insights of the data. To do so, we will use as_datetime() function from lubridate package.\n\ndf_trajectories$pingtimestamp &lt;- as_datetime(df_trajectories$pingtimestamp)\n\n\n\n4.3 Importing OpenStreetMap road data for Malaysia, Singapore and Brunei\nThe gis_osm_roads_free_1 dataset, which we downloaded from OpenStreetMap, is in ESRI shapefile format. To use this data in an R-environment, we need to import it as an sf object. We can do this using the st_read() function of the sf package. This function reads the shapefile data and returns an sf object that can be used for further analysis.\n\nosm_road_sf &lt;- st_read(dsn = \"~/IS415-GAA/data/geospatial\", \n                layer = \"gis_osm_roads_free_1\") %&gt;% st_transform(crs = 3414)\n\n\n\n4.4 Importing Singapore Master Plan Planning Subzone boundary data\nThe MP14_SUBZONE_WEB_PL dataset, which we downloaded from data.gov.sg, is in ESRI shapefile format. To use this data in an R-environment, we need to import it as an sf object. We can do this using the st_read() function of the sf package. This function reads the shapefile data and returns an sf object that can be used for further analysis.\n\nmpsz_sf &lt;- st_read(dsn = \"~/IS415-GAA/data/geospatial\", \n                layer = \"MPSZ-2019\") %&gt;% st_transform(crs = 3414)\n\nReading layer `MPSZ-2019' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nReflection\n\n\n\nIn the code chunk above, we use %&gt;% operator is used to pipe the output of st_read() to the st_transform() function. Since the dataset we are using is the Singapore boundary, we need to assign the standard coordinate reference system for Singapore, which is SVY21 (EPSG:3414). st_transform() function transforms the coordinate reference system of the sf object to 3414.\n\n\nAfter importing the dataset, we will plot it to see how it looks. The plot() function is used to plot the geometry of the sf object. The st_geometry() function is used to extract the geometry of the mpsz_sf object.\n\nplot(st_geometry(mpsz_sf))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex01.html#data-wrangling",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "5.0 Data Wrangling",
    "text": "5.0 Data Wrangling\nData wrangling is the process of converting and transforming raw data into a usable form and is carried out prior to conducting any data analysis.\n\n5.1 Extracting Trip Starting Locations and Temporal Data Values from Grab-Posisi dataset\nFirstly, we will extract trip starting locations for all unqiue trajectories in the dataset and store them to a new df named origin_df. We are also interested in obtaining valuable temporal data such as the day of the week, the hour, and the date (yy-mm-dd). To do so, we will use the following functions from lubridate package, and add the newly derived values as columns to origin_df.\n\nwday: allows us to get days component of a date-time\nhour: allows us to get hours component of a date-time\nmday: allows us to parse dates with year, month, and day components\n\n\norigin_df &lt;- df_trajectories %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(pingtimestamp) %&gt;%\n  filter(row_number()==1) %&gt;% \n  mutate(weekday = wday(pingtimestamp,\n                       label=TRUE,\n                       abbr=TRUE),\n         pickup_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp)))\n\n\n\n5.2 Extracting Trip Ending Locations and Temporal Data Values from Grab-Posisi dataset\nSimilar to what we did in previous session, we are also interested to extract trip ending locations and associated temporal data into a new df called destination_df. We will use the same functions from previous session here.\n\ndestination_df &lt;- df_trajectories %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(desc(pingtimestamp)) %&gt;%\n  filter(row_number()==1) %&gt;% \n  mutate(weekday = wday(pingtimestamp,\n                       label=TRUE,\n                       abbr=TRUE),\n         dropoff_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp)))\n\n\n\n\n\n\n\nReflection\n\n\n\narrange() function sort the timestamps in ascending order by default. Hence, this default order is applied to origin_df. However, for destination_df, the arrange(desc()) argument is used to modify the default order to descending.\n\n\n\n\n5.3 Converting to sf tibble data.frame\n\norigin_sf &lt;- st_as_sf(origin_df,\n                      coords = c(\"rawlng\", \"rawlat\"),\n                      crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\ndestination_sf &lt;- st_as_sf(destination_df,\n                      coords = c(\"rawlng\", \"rawlat\"),\n                      crs = 4326) %&gt;%\n  st_transform(crs = 3414)\n\n\n\n5.4 Creating a CoastalLine of Singapore\nThe original mpsz_sf dataset we imported include information of all URA Master Plan planning area boundaries. However, for this analysis, we only need the national-level boundary of Singapore. Hence, we will need to union all the subzone boundaries to one single polygon boundary. Also, Grab ride-hailing service is only available on the main Singapore islands. Hence, we will need to remove outer islands which Grab service is not available. In particular, we will remove the following planning subzones: NORTH-EASTERN ISLANDS, SOUTHERN GROUP, SUDONG & SEMAKAU.\nWe can remove these subzones using the subset() function. The subset() function is used to extract rows from a data frame that meet certain conditions.\n\nnortheasten.islands &lt;- subset(mpsz_sf, mpsz_sf$SUBZONE_N == \"NORTH-EASTERN ISLANDS\")\nsouthern.islands &lt;- subset(mpsz_sf, mpsz_sf$SUBZONE_N == \"SOUTHERN GROUP\")\nsudong &lt;- subset(mpsz_sf, mpsz_sf$SUBZONE_N == \"SUDONG\")\nsemakau &lt;- subset(mpsz_sf,mpsz_sf$SUBZONE_N == \"SEMAKAU\")\n\nouterislands &lt;- dplyr::bind_rows(list(northeasten.islands,southern.islands,sudong,semakau))\n\n\n\n\n\n\n\nReflection\n\n\n\nIn the code chunk above, we first created four new data frames called northeasten.islands, southern.islands, sudong, and semakau by selecting rows from mpsz_sf where the value in the SUBZONE_N column matches the corresponding value.\nAfter that, we used bind_rows() function from the dplyr package to combine these four data frames into a single data frame called outerislands.\n\n\nAfter importing the dataset, we will plot it to see how it looks.\n\nplot(st_geometry(outerislands))\n\n\n\n\nAs mentioned earlier, we only need to get national-level boundary of Singapore, without outer islands. To do so, we will need to process the mpsz_sf layer to achieve the outcome. - We will first use st_union() function from the sf package to combine the geometries of mpsz_sf and outerislands sf objects into a single geometry each. - Next, we will use st_difference() function then removes the overlapping areas between the two geometries. - Finally, we will store the non-overlapping areas into a new sf objected called sg_sf.\n\nsg_sf &lt;- st_difference(st_union(mpsz_sf), st_union(outerislands))\n\nTo assess whether the geometry of the newly created sg_sf matches our intended outcome, we will plot it out.\n\nplot(st_geometry(sg_sf))\n\n\n\n\n\n\n5.5 Extracting Road Layers within Singapore\nAs we have seen in Section 4.3., osm_road_sf dataset includes road networks from not only Singapore, but also Malaysia and Brunei. However, our analysis is focused on Singapore. Hence, we will need to remove unecessary data rows. To do so, we will\n\nsg_road_sf &lt;- st_intersection(osm_road_sf,lsg_sf)\n\nNext, we will look at the classification of road networks as provided by OpenStreetMap.\n\nunique(sg_road_sf$fclass)\n\n [1] \"primary\"        \"residential\"    \"tertiary\"       \"footway\"       \n [5] \"service\"        \"secondary\"      \"motorway\"       \"motorway_link\" \n [9] \"trunk\"          \"trunk_link\"     \"primary_link\"   \"pedestrian\"    \n[13] \"living_street\"  \"unclassified\"   \"steps\"          \"track_grade2\"  \n[17] \"track\"          \"secondary_link\" \"cycleway\"       \"path\"          \n[21] \"tertiary_link\"  \"track_grade1\"   \"track_grade3\"   \"unknown\"       \n[25] \"track_grade5\"   \"bridleway\"      \"track_grade4\"  \n\n\nLooking at the road classification, it is observed that not all categories are relevant to our analysis, which is primarily concerned with driving networks where taxis can facilitate pick-ups or drop-offs. Hence, we will implement a filtering process on the dataset to exclude road segments that fall outside the scope of our analysis.\nFirstly we will specify the road classes that we want to retain.\n\ndriving_classes &lt;- c(\"primary\", \"primary_link\", \"residential\", \"secondary\", \"secondary_link\", \"service\", \"tertiary\", \"tertiary_link\") \n\nNext, we will filter sg_road_sf object to remove all the rows that does not have our desired f_class attribute value.\n\nsg_driving_sf &lt;- sg_road_sf %&gt;%\n  filter(fclass %in% driving_classes)\nunique(sg_driving_sf$fclass)\n\n[1] \"primary\"        \"residential\"    \"tertiary\"       \"service\"       \n[5] \"secondary\"      \"primary_link\"   \"secondary_link\" \"tertiary_link\" \n\n\n\n\n\n\n\n\nTip\n\n\n\nWhy motorway and motorway_link classes are not included?\nAccording to OpenStreetMap, fclass motorway refers to expressway. In Singapore, stopping or parking a vehicle on an expressway is illegal under the Road Traffic Act. Hence, motorway (and motorway_link) are not relevant for network constraint kernel density estimation (NKDE) analysis that we will carry out later.\n\n\nNow that we have filterd out the dataset, we will now plot to see the driving road network of Singapore using tmap.\n\ntmap_mode(\"plot\")\n\ntm_shape(sg_sf) +\n  tm_polygons() +\ntm_shape(sg_driving_sf) +\n  tm_lines(col=\"fclass\", palette =\"viridis\") +\n  tm_layout(main.title = \"Road Network in Singapore\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n5.5 Converting the Simple Features to Planar Point Pattern Object\nIn order to use the capabilities of spatstat packahe, a spatial dataset should be converted into an object of class planar point pattern ppp (Baddeley et al., 2015). A point pattern object contains the spatial coordinates of the points, the marks attached to the points (if any), the window in which the points were observed, and the name of the unit of length for the spatial coordinates. s. Thus, a single object of class ppp contains all the information required to perform spatial point pattern analysis.\nIn previous section, we have created sf objects of Grab trajectory origin and destination points. Now, we will convert them into ppp objects using as.ppp() function from spatstat package.\n\norigin_ppp &lt;- as.ppp(st_coordinates(origin_sf), st_bbox(origin_sf))\n\npar(mar = c(0,0,1,0))\nplot(origin_ppp)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe code chunk above converts the origin_sf object to a point pattern object of class ppp. st_coordinates() function is used to extract the coordinates of the origin_sf object and st_bbox() function is used to extract the bounding box of the origin_sf object. The resulting object origin_ppp is a point pattern object of class ppp.\n\n\n\ndestination_ppp &lt;- as.ppp(st_coordinates(destination_sf), st_bbox(destination_sf))\n\npar(mar = c(0,0,1,0))\nplot(destination_ppp)\n\n\n\n\n\n\n5.6 Handling Data Errors\nBefore going striaght into analysis, we will need to a quick look at the summary statistics of the newly created ppp objects. This is an important step to ensure that the data is free of errors and that a reliable analysis can be performed.\n\n5.6.1 Data Error Handling for origin_ppp\nWe will use summary() function to get summary information of origin_ppp object.\n\nsummary(origin_ppp)\n\nPlanar point pattern:  28000 points\nAverage intensity 2.473666e-05 points per square unit\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: rectangle = [3628.24, 49845.23] x [25198.14, 49689.64] units\n                    (46220 x 24490 units)\nWindow area = 1131920000 square units\n\n\nWe can also check if there is any duplicated points in origin_ppp object using any(duplicated() function.\n\nany(duplicated(origin_ppp))\n\n[1] FALSE\n\n\nThe code output is FALSE, which means there are no duplication of point coordaintes in the origin_ppp object.\n\nWhy do we need to check duplication?\nWhen analyzing spatial point processes, it is important to avoid duplication of points. This is because statistical methodology for spatial point processes is based largely on the assumption that processes are simple, i.e., that points of the process can never be coincident. When the data have coincident points, some statistical procedures designed for simple point processes will be severely affected (Baddeley et al., 2015).\n\n\n\n5.6.2 Data Error Handling for destination_ppp\nWe will use summary() function to get summary information of destination_ppp object.\n\nsummary(destination_ppp)\n\nPlanar point pattern:  28000 points\nAverage intensity 2.493661e-05 points per square unit\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: rectangle = [3637.21, 49870.63] x [25221.3, 49507.79] units\n                    (46230 x 24290 units)\nWindow area = 1122850000 square units\n\n\nWe can also check if there is any duplicated points in destination_ppp object using any(duplicated() function.\n\nany(duplicated(destination_ppp))\n\n[1] FALSE\n\n\nThe code output is FALSE, which means there are no duplication of point coordinates in the destination_ppp object.\n\n\n\n5.7 Creating Observation Windows\nMany data types in spatstat require us to specify the region of space inside which the data were observed. This is the observation window and it is represented by an object of class owin. In this analysis, our study area is Singapore, hence we will use Singapore boundary as the observation window for spatial point pattern analysis.\nIn Section 5.4, we have already created the sg_sf object, which represents the Singapore boundary (without outer islands). To convert this sf object to owin object, we will use as.owin() function from spatstat package.\n\nsg_owin &lt;- as.owin(sg_sf)\nplot.owin(sg_owin)\n\n\n\n\nWe will use summary() function to get summary information of sg_owin object.\n\nsummary(sg_owin)\n\nWindow: polygonal boundary\n56 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1            15307  7.00834e+08      9.92e-01\npolygon 2              285  1.61128e+06      2.28e-03\npolygon 3               27  1.50315e+04      2.13e-05\npolygon 4 (hole)        41 -4.01660e+04     -5.69e-05\npolygon 5 (hole)       317 -5.11280e+04     -7.24e-05\npolygon 6 (hole)         3 -4.14099e-04     -5.86e-13\npolygon 7               30  2.80002e+04      3.97e-05\npolygon 8 (hole)         4 -2.86396e-01     -4.06e-10\npolygon 9 (hole)         3 -1.81439e-04     -2.57e-13\npolygon 10 (hole)        3 -8.68789e-04     -1.23e-12\npolygon 11 (hole)        3 -5.99535e-04     -8.49e-13\npolygon 12 (hole)        3 -3.04561e-04     -4.31e-13\npolygon 13 (hole)        3 -4.46076e-04     -6.32e-13\npolygon 14 (hole)        3 -3.39794e-04     -4.81e-13\npolygon 15 (hole)        3 -4.52043e-05     -6.40e-14\npolygon 16 (hole)        3 -3.90173e-05     -5.53e-14\npolygon 17 (hole)        3 -9.59850e-05     -1.36e-13\npolygon 18 (hole)        4 -2.54488e-04     -3.60e-13\npolygon 19 (hole)        4 -4.28453e-01     -6.07e-10\npolygon 20 (hole)        4 -2.18616e-04     -3.10e-13\npolygon 21 (hole)        5 -2.44411e-04     -3.46e-13\npolygon 22 (hole)        5 -3.64686e-02     -5.16e-11\npolygon 23              71  8.18750e+03      1.16e-05\npolygon 24 (hole)        6 -8.37554e-01     -1.19e-09\npolygon 25 (hole)       38 -7.79904e+03     -1.10e-05\npolygon 26 (hole)        3 -3.41897e-05     -4.84e-14\npolygon 27 (hole)        3 -3.65499e-03     -5.18e-12\npolygon 28 (hole)        3 -4.95057e-02     -7.01e-11\npolygon 29              91  1.49663e+04      2.12e-05\npolygon 30 (hole)        3 -3.79135e-02     -5.37e-11\npolygon 31 (hole)        5 -2.92235e-04     -4.14e-13\npolygon 32 (hole)        3 -7.43616e-06     -1.05e-14\npolygon 33 (hole)      270 -1.21455e+03     -1.72e-06\npolygon 34 (hole)       19 -4.39650e+00     -6.23e-09\npolygon 35 (hole)       35 -1.38385e+02     -1.96e-07\npolygon 36 (hole)       23 -1.99656e+01     -2.83e-08\npolygon 37              40  1.38607e+04      1.96e-05\npolygon 38 (hole)       41 -6.00381e+03     -8.50e-06\npolygon 39 (hole)        7 -1.40546e-01     -1.99e-10\npolygon 40 (hole)       11 -8.36705e+01     -1.18e-07\npolygon 41 (hole)        3 -2.33435e-03     -3.31e-12\npolygon 42              45  2.51218e+03      3.56e-06\npolygon 43             139  3.22293e+03      4.56e-06\npolygon 44             148  3.10395e+03      4.40e-06\npolygon 45 (hole)        4 -1.72650e-04     -2.44e-13\npolygon 46              75  1.73526e+04      2.46e-05\npolygon 47              83  5.28920e+03      7.49e-06\npolygon 48             106  3.04104e+03      4.31e-06\npolygon 49             264  1.50631e+06      2.13e-03\npolygon 50              71  5.63061e+03      7.97e-06\npolygon 51              10  1.99717e+02      2.83e-07\npolygon 52 (hole)        3 -1.37223e-02     -1.94e-11\npolygon 53             487  2.06117e+06      2.92e-03\npolygon 54              65  8.42861e+04      1.19e-04\npolygon 55              47  3.82087e+04      5.41e-05\npolygon 56              22  6.74651e+03      9.55e-06\nenclosing rectangle: [2667.54, 55941.94] x [21448.47, 50256.33] units\n                     (53270 x 28810 units)\nWindow area = 706156000 square units\nFraction of frame area: 0.46\n\n\n\n\n5.8 Combining ppp objects and owin object\nIn section 5.5, we have created two ppp objects - origin_ppp and destination_ppp, each representing the spatial points of Grab trajectory origin and destination. In section 5.7, we have created a owin object called sg_owin, which represent the observation window of our analysis.\nThe observation window sg_owin and the point pattern origin_ppp or destination_ppp can be combined, so that the custom window replaces the default ractangular extent (as seen in section 5.5).\n\norigin_ppp_sg = origin_ppp[sg_owin]\ndestination_ppp_sg = destination_ppp[sg_owin]\n\npar(mar = c(0,0,1,0))\nplot(origin_ppp_sg)\n\n\n\nplot(destination_ppp_sg)\n\n\n\n\nWe will use summary() function to get summary information of the newly created origin_ppp_sg object and destination_ppp_sg object.\n\nsummary(origin_ppp_sg)\n\nPlanar point pattern:  28000 points\nAverage intensity 3.965129e-05 points per square unit\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: polygonal boundary\n56 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1            15307  7.00834e+08      9.92e-01\npolygon 2              285  1.61128e+06      2.28e-03\npolygon 3               27  1.50315e+04      2.13e-05\npolygon 4 (hole)        41 -4.01660e+04     -5.69e-05\npolygon 5 (hole)       317 -5.11280e+04     -7.24e-05\npolygon 6 (hole)         3 -4.14099e-04     -5.86e-13\npolygon 7               30  2.80002e+04      3.97e-05\npolygon 8 (hole)         4 -2.86396e-01     -4.06e-10\npolygon 9 (hole)         3 -1.81439e-04     -2.57e-13\npolygon 10 (hole)        3 -8.68789e-04     -1.23e-12\npolygon 11 (hole)        3 -5.99535e-04     -8.49e-13\npolygon 12 (hole)        3 -3.04561e-04     -4.31e-13\npolygon 13 (hole)        3 -4.46076e-04     -6.32e-13\npolygon 14 (hole)        3 -3.39794e-04     -4.81e-13\npolygon 15 (hole)        3 -4.52043e-05     -6.40e-14\npolygon 16 (hole)        3 -3.90173e-05     -5.53e-14\npolygon 17 (hole)        3 -9.59850e-05     -1.36e-13\npolygon 18 (hole)        4 -2.54488e-04     -3.60e-13\npolygon 19 (hole)        4 -4.28453e-01     -6.07e-10\npolygon 20 (hole)        4 -2.18616e-04     -3.10e-13\npolygon 21 (hole)        5 -2.44411e-04     -3.46e-13\npolygon 22 (hole)        5 -3.64686e-02     -5.16e-11\npolygon 23              71  8.18750e+03      1.16e-05\npolygon 24 (hole)        6 -8.37554e-01     -1.19e-09\npolygon 25 (hole)       38 -7.79904e+03     -1.10e-05\npolygon 26 (hole)        3 -3.41897e-05     -4.84e-14\npolygon 27 (hole)        3 -3.65499e-03     -5.18e-12\npolygon 28 (hole)        3 -4.95057e-02     -7.01e-11\npolygon 29              91  1.49663e+04      2.12e-05\npolygon 30 (hole)        3 -3.79135e-02     -5.37e-11\npolygon 31 (hole)        5 -2.92235e-04     -4.14e-13\npolygon 32 (hole)        3 -7.43616e-06     -1.05e-14\npolygon 33 (hole)      270 -1.21455e+03     -1.72e-06\npolygon 34 (hole)       19 -4.39650e+00     -6.23e-09\npolygon 35 (hole)       35 -1.38385e+02     -1.96e-07\npolygon 36 (hole)       23 -1.99656e+01     -2.83e-08\npolygon 37              40  1.38607e+04      1.96e-05\npolygon 38 (hole)       41 -6.00381e+03     -8.50e-06\npolygon 39 (hole)        7 -1.40546e-01     -1.99e-10\npolygon 40 (hole)       11 -8.36705e+01     -1.18e-07\npolygon 41 (hole)        3 -2.33435e-03     -3.31e-12\npolygon 42              45  2.51218e+03      3.56e-06\npolygon 43             139  3.22293e+03      4.56e-06\npolygon 44             148  3.10395e+03      4.40e-06\npolygon 45 (hole)        4 -1.72650e-04     -2.44e-13\npolygon 46              75  1.73526e+04      2.46e-05\npolygon 47              83  5.28920e+03      7.49e-06\npolygon 48             106  3.04104e+03      4.31e-06\npolygon 49             264  1.50631e+06      2.13e-03\npolygon 50              71  5.63061e+03      7.97e-06\npolygon 51              10  1.99717e+02      2.83e-07\npolygon 52 (hole)        3 -1.37223e-02     -1.94e-11\npolygon 53             487  2.06117e+06      2.92e-03\npolygon 54              65  8.42861e+04      1.19e-04\npolygon 55              47  3.82087e+04      5.41e-05\npolygon 56              22  6.74651e+03      9.55e-06\nenclosing rectangle: [2667.54, 55941.94] x [21448.47, 50256.33] units\n                     (53270 x 28810 units)\nWindow area = 706156000 square units\nFraction of frame area: 0.46\n\nsummary(destination_ppp_sg)\n\nPlanar point pattern:  27997 points\nAverage intensity 3.964704e-05 points per square unit\n\nCoordinates are given to 3 decimal places\ni.e. rounded to the nearest multiple of 0.001 units\n\nWindow: polygonal boundary\n56 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1            15307  7.00834e+08      9.92e-01\npolygon 2              285  1.61128e+06      2.28e-03\npolygon 3               27  1.50315e+04      2.13e-05\npolygon 4 (hole)        41 -4.01660e+04     -5.69e-05\npolygon 5 (hole)       317 -5.11280e+04     -7.24e-05\npolygon 6 (hole)         3 -4.14099e-04     -5.86e-13\npolygon 7               30  2.80002e+04      3.97e-05\npolygon 8 (hole)         4 -2.86396e-01     -4.06e-10\npolygon 9 (hole)         3 -1.81439e-04     -2.57e-13\npolygon 10 (hole)        3 -8.68789e-04     -1.23e-12\npolygon 11 (hole)        3 -5.99535e-04     -8.49e-13\npolygon 12 (hole)        3 -3.04561e-04     -4.31e-13\npolygon 13 (hole)        3 -4.46076e-04     -6.32e-13\npolygon 14 (hole)        3 -3.39794e-04     -4.81e-13\npolygon 15 (hole)        3 -4.52043e-05     -6.40e-14\npolygon 16 (hole)        3 -3.90173e-05     -5.53e-14\npolygon 17 (hole)        3 -9.59850e-05     -1.36e-13\npolygon 18 (hole)        4 -2.54488e-04     -3.60e-13\npolygon 19 (hole)        4 -4.28453e-01     -6.07e-10\npolygon 20 (hole)        4 -2.18616e-04     -3.10e-13\npolygon 21 (hole)        5 -2.44411e-04     -3.46e-13\npolygon 22 (hole)        5 -3.64686e-02     -5.16e-11\npolygon 23              71  8.18750e+03      1.16e-05\npolygon 24 (hole)        6 -8.37554e-01     -1.19e-09\npolygon 25 (hole)       38 -7.79904e+03     -1.10e-05\npolygon 26 (hole)        3 -3.41897e-05     -4.84e-14\npolygon 27 (hole)        3 -3.65499e-03     -5.18e-12\npolygon 28 (hole)        3 -4.95057e-02     -7.01e-11\npolygon 29              91  1.49663e+04      2.12e-05\npolygon 30 (hole)        3 -3.79135e-02     -5.37e-11\npolygon 31 (hole)        5 -2.92235e-04     -4.14e-13\npolygon 32 (hole)        3 -7.43616e-06     -1.05e-14\npolygon 33 (hole)      270 -1.21455e+03     -1.72e-06\npolygon 34 (hole)       19 -4.39650e+00     -6.23e-09\npolygon 35 (hole)       35 -1.38385e+02     -1.96e-07\npolygon 36 (hole)       23 -1.99656e+01     -2.83e-08\npolygon 37              40  1.38607e+04      1.96e-05\npolygon 38 (hole)       41 -6.00381e+03     -8.50e-06\npolygon 39 (hole)        7 -1.40546e-01     -1.99e-10\npolygon 40 (hole)       11 -8.36705e+01     -1.18e-07\npolygon 41 (hole)        3 -2.33435e-03     -3.31e-12\npolygon 42              45  2.51218e+03      3.56e-06\npolygon 43             139  3.22293e+03      4.56e-06\npolygon 44             148  3.10395e+03      4.40e-06\npolygon 45 (hole)        4 -1.72650e-04     -2.44e-13\npolygon 46              75  1.73526e+04      2.46e-05\npolygon 47              83  5.28920e+03      7.49e-06\npolygon 48             106  3.04104e+03      4.31e-06\npolygon 49             264  1.50631e+06      2.13e-03\npolygon 50              71  5.63061e+03      7.97e-06\npolygon 51              10  1.99717e+02      2.83e-07\npolygon 52 (hole)        3 -1.37223e-02     -1.94e-11\npolygon 53             487  2.06117e+06      2.92e-03\npolygon 54              65  8.42861e+04      1.19e-04\npolygon 55              47  3.82087e+04      5.41e-05\npolygon 56              22  6.74651e+03      9.55e-06\nenclosing rectangle: [2667.54, 55941.94] x [21448.47, 50256.33] units\n                     (53270 x 28810 units)\nWindow area = 706156000 square units\nFraction of frame area: 0.46"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#exploratory-spatial-data-analysis",
    "href": "Take-home_Ex/Take-home_Ex01.html#exploratory-spatial-data-analysis",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "6.0 Exploratory Spatial Data Analysis",
    "text": "6.0 Exploratory Spatial Data Analysis\n\n6.1 Creating Point Symbol Maps\n\ntmap_mode(\"view\")\ntm_shape(origin_sf) +\n    tm_dots(alpha=0.4, \n          size=0.05)\n\ntm_shape(destination_sf) +\n    tm_dots(alpha=0.4, \n          size=0.05)\n\n\n\n6.2 Measuring Central Tendency\nDescriptive statistics are used in point pattern analysis to summarise a point pattern’s basic properties, such as its central tendency and dispersion. The mean centre and the median centre are two often employed metrics for central tendency (Gimond, 2019).\n\n6.2.1 Mean Center\nMean center is the arithmetic average of the (x, y) coordinates of all point in the study area. Similar to mean in statistical analysis, mean center is influenced to a greater degree by the outliers. (Yuan et al.,2020)\n\norigin_xy &lt;- st_coordinates(origin_sf)\norigin_mc &lt;- apply(origin_xy, 2, mean)\n\ndestination_xy &lt;- st_coordinates(destination_sf)\ndestination_mc &lt;- apply(destination_xy, 2, mean)\n\norigin_mc\n\n       X        Y \n28490.57 36939.04 \n\ndestination_mc\n\n       X        Y \n28870.96 36590.49 \n\n\nThe results show that the origin and destination mean centres are, respectively, (28490.57, 36939.04) and (28870.96, 36590.49). The two mean centres appear to be situated in close proximity to one another.\n\n\n6.2.2 Median Center\nMedian center is the location that minimizes the sum of distances required to travel to all points within an observation window. It can be calculated using an iterative procedure first presented by Kulin and Kuenne (1962). The procedure begins at a predetermined point, such as the median center, as the initial point. Then, the algorithm updates the median center’s new coordinates (x’, y’) continually until the optimal value is reached. The median center, as opposed to the mean center, offers a more reliable indicator of central tendency as it is unaffected by outliers (Yuan et al., 2020).\n\norigin_medc &lt;- apply(origin_xy, 2, median)\n\ndestination_medc &lt;- apply(destination_xy, 2, median)\n\norigin_medc\n\n       X        Y \n28553.17 36179.05 \n\ndestination_medc\n\n       X        Y \n28855.04 35883.86 \n\n\nBased on the results, the median centres of origin and destination are, respectively, (28553.17, 36179.05) and (28855.04, 35883.86). The two median centres appear to be situated in close proximity to one another.\nMoreover, mean centers and median centers for each origin and destination points are similar. This may imply that the distribution of the data is relatively balanced and there is not a significant difference in the spatial patterns between the origin and destination points. Additionally, this indicates that both the mean center and median center are effective measures for analyzing the central tendency of the data in this context.\n\n\n6.2.3 Plotting Mean and Median Centers\nWe can try to plot both results obtained from previous section on the same plane for better comparison of the mean center and median center.\n\npar(mar = c(0,0,1,0))\n\nplot(sg_sf, col='light grey', main=\"mean and median centers of origin_sf\")\npoints(origin_xy, cex=.5)\npoints(cbind(origin_mc[1], origin_mc[2]), pch='*', col='red', cex=3)\npoints(cbind(origin_medc[1], origin_medc[2]), pch='*', col='purple', cex=3)\n\n\n\n\n\npar(mar = c(0,0,1,0))\n\nplot(sg_sf, col='light grey', main=\"mean and median centers of destination_sf\")\npoints(destination_xy, cex=.5)\npoints(cbind(destination_mc[1], destination_mc[2]), pch='*', col='yellow', cex=3)\npoints(cbind(destination_medc[1], destination_medc[2]), pch='*', col='orange', cex=3)\n\n\n\n\n\n\n\n6.2 Measuring Dispersion\n\n6.2.1 Standard Distance\nStandard distances are defined similarly to standard deviations. This indicator measures how dispersed a group of points is around its mean center (Gimond, 2023).\n\norigin_sd &lt;- sqrt(sum((origin_xy[,1] - origin_mc[1])^2 + (origin_xy[,2] - origin_mc[2])^2) / nrow(origin_xy))\n\ndestination_sd &lt;- sqrt(sum((destination_xy[,1] - destination_mc[1])^2 + (destination_xy[,2] - destination_mc[2])^2) / nrow(destination_xy))\n\norigin_sd\n\n[1] 10187.88\n\ndestination_sd\n\n[1] 9545.69\n\n\nFrom the results, the origin and destination standard distances are 10187.88 and 9545.69, respectively. Hence, it appears that origin points are more dispersed than the origin points.\n\n\n\n\n\n\nReflection\n\n\n\nHowever, it would be challenging to discern why the origin points are more dispersed without further analysis. Further analysis would be needed to determine the factors contributing to the increased dispersion of destination points. Since it is out of scope for this exercise, we will not explore any further.\n\n\n\n\n6.2.3 Plotting Standard Distances\nIn this section, we will create bearing circles of origin and destination points using the standard distance values we have calculated earlier. This can provide visual representation of their dispersion and make intuitive comparison between them.\n\npar(mar = c(0,0,1,0))\nplot(sg_sf, col='light grey', main=\"standard distance of origin_sf\")\npoints(origin_xy, cex=.5)\npoints(cbind(origin_mc[1], origin_mc[2]), pch='*', col='red', cex=3)\n\nbearing &lt;- 1:360 * pi/180\ncx &lt;- origin_mc[1] + origin_sd * cos(bearing)\ncy &lt;- origin_mc[2] + origin_sd * sin(bearing)\ncircle &lt;- cbind(cx, cy)\nlines(circle, col='red', lwd=2)\n\n\n\n\n\npar(mar = c(0,0,1,0))\nplot(sg_sf, col='light grey',main=\"standard distance of destination_sf\")\npoints(destination_xy, cex=.5)\npoints(cbind(destination_mc[1], destination_mc[2]), pch='*', col='purple', cex=3)\n\nbearing &lt;- 1:360 * pi/180\ncx &lt;- destination_mc[1] + destination_sd * cos(bearing)\ncy &lt;- destination_mc[2] + destination_sd * sin(bearing)\ncircle &lt;- cbind(cx, cy)\nlines(circle, col='purple', lwd=2)\n\n\n\n\nA better comparison of the standard distances between origin and destination points can also be achieved by trying to plot both results on the same plane.\n\npar(mar = c(0,0,1,0))\n\nplot(sg_sf, col='light grey',main=\"standard distances of origin_sf & destination_sf\")\npoints(cbind(origin_mc[1], origin_mc[2]), pch='*', col='red', cex=3)\npoints(cbind(destination_mc[1], destination_mc[2]), pch='*', col='purple', cex=3)\n\nbearing &lt;- 1:360 * pi/180\n\norigin_cx &lt;- origin_mc[1] + origin_sd * cos(bearing)\norigin_cy &lt;- origin_mc[2] + origin_sd * sin(bearing)\n\ndestination_cx &lt;- destination_mc[1] + destination_sd * cos(bearing)\ndestination_cy &lt;- destination_mc[2] + destination_sd * sin(bearing)\n\norigin_circle &lt;- cbind(origin_cx, origin_cy)\ndestination_circle &lt;- cbind(destination_cx, destination_cy)\n\nlines(origin_circle, col='red', lwd=2)\nlines(destination_circle, col='purple', lwd=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#first-order-spatial-point-patterns-analysis",
    "href": "Take-home_Ex/Take-home_Ex01.html#first-order-spatial-point-patterns-analysis",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "7.0 First-Order Spatial Point Patterns Analysis",
    "text": "7.0 First-Order Spatial Point Patterns Analysis\nAfter data wrangling is complete, we will start to perform first-order spatial point pattern analysis using functions from spatstat package. As we have discussed in Section 2.0., First-order properties concern the characteristics of individual point locations and their variations of their density across space and are mostly addressed by density-based techniques, such as quadrant analysis and kernel density estimation.\nInvestigation of the intensity of a point pattern is one of the first and most important steps in point pattern analysis (Baddeley et al., 2015). If the point process has an intensity function λ(u), this function can be estimated non-parametrically by kernel estimation (Baddeley et al., 2015). Kernel estimation allows for smoothing of the probability density estimation of a random variable (in this analysis a point event) based on kernels as weights.\n\n7.1 Rescaling origin_ppp_sg and destination_ppp_sg\nThe SVY21 Coordinate References System uses meters as the standard unit. Hence, the original_ppp_sg and destination_ppp_sg that we have prepared in the previous sections has “metres” as the unit. However, we will need to convert the measuring unit from metre to kilometeres when calculating the kernel density estimators for entirety of Singapore because kilometers provide a more appropriate scale for analyzing large areas.\n\norigin_ppp_sg.km &lt;- rescale(origin_ppp_sg, 1000, \"km\")\ndestination_ppp_sg.km &lt;- rescale(destination_ppp_sg, 1000, \"km\")\n\n\n\n7.2 Computing Default Kernel Density Estimation\nKernel Destiny Estimation (KDE) generates a surface (raster) representing the estimated distribution of point events over the observation window. Each cell in the KDE layer carries a value representing the estimated density of that location (Wilkin, 2020). Hence, this approach is also known as local density approach. To build the KDE layer, a localised density is calculated for multiple small subsets of the observation window. However, these subsets overlap throughout each iteration, resulting in a moving window defined by a kernel (Wilkin, 2020; Gimond, 2023).\nIn this section, we will focus on destination points as we would like to identify areas that exert a ‘pull’ effect on people, hence resulting in cluster of trajectory destinations. Analyzing the destination of Grab trajectories can provide interesting insights into pull factors within a given area and help identify popular destinations or areas of high mobility demand.\nKernel estimation is implemented in spatstat by the function density.ppp(), a method for the generic command density.\n\npar(mar = c(0,1,1,1))\nkde_default_destination &lt;- density(destination_ppp_sg.km)\nplot(kde_default_destination,main = \"Default Density KDE for Destination Points\")\ncontour(kde_default_destination, add=TRUE)\n\n\n\n\nsigma argument in density() function controls the bandwidth of kernel function. The choice of the bandwidth affects the kernel density estimation strongly. A smaller bandwidth will produce a finer density estimate with all little peaks and valleys. A larger bandwidth will result into a smoother distribution of point densities. Generally speaking, if the bandwidth is too small the estimate is too noisy, while if bandwidth is too high the estimate may miss crucial elements of the point pattern due to over-smoothing (Scott, 2009).\n\n\n\nDensity Estimates with Different Smoothing Bandwidth (Ref, Baddeley et al., 2015)\n\n\nWhen sigma value is not specified, an isotropic Gaussian kernel will be used, with a default value of sigma calculated by a simple rule of thumb that depends only on the size of the window. Hence, the KDE given by default argument may not be what we aim to achieve. Looking at the KDE plot we have created above, there are signs of oversmoothing where only a single spatial cluster in the CBD area being observable. This can severely limit our analysis as potential small-scale clusters and other interesting details are being masked by the oversmoothing effect.\nTo overcome this challenge, we can specify smoothing bandwidth through the argument sigma or kernel function through the argument kernel to compute and plot more intuitive and detailed KDE maps.\n\n\n7.3 Creating KDE Layers with Fixed Bandwidth\n\n7.3.1 Computing Fixed Bandwidths Using Different Bandwidth Selection Methods\ndensity() function of spatstat allows us to compute a kernel density for a given set of point events.\n\nbw.diggle() Cross Validated Bandwidth Selection for Kernel Density: In this method, band-width σ is chosen to minimize the mean-square error criterion defined by Diggle (1985). The mean-square error is a measure of the average of the squares of the errors - that is, the average squared difference between the estimated values and the actual value.\nbw.CvL() Cronie and van Lieshout’s Criterion for Bandwidth Selection for Kernel Density: The bandwidth σ is chosen to minimize the discrepancy between the area of the observation window and the sum of reciprocal estimated intensity values at the points of the point process. This method aims to choose a bandwidth that best represents the underlying point process, taking into account both the observed points and the area they occupy.\nbw.scott() Scott’s Rule for Bandwidth Selection for Kernel Density: The bandwidth σ is computed by the rule of thumb of Scott (1992). The bandwidth is proportional to \\(n^{-1/(d-4)}\\) where n is the number of points and d is the number of spatial dimensions. This rule is very fast to compute. It typically produces a larger bandwidth than Diggle’s method. It is useful for estimating gradual trend.\nbw.ppl() Likelihood Cross Validation Bandwidth Selection for Kernel Density: This approach, explained by Loader (1999), uses likelihood cross-validation to determine the bandwidth (σ) by maximizing the point process likelihood. This method is beneficial when the aim is to maximize the likelihood of observing the given data.\n\n\nbw_diggle &lt;- bw.diggle(destination_ppp_sg.km)\nbw_diggle\n\n      sigma \n0.008317447 \n\nbw_CvL &lt;- bw.CvL(destination_ppp_sg.km)\nbw_CvL\n\n   sigma \n3.745658 \n\nbw_scott &lt;- bw.scott(destination_ppp_sg.km)\nbw_scott\n\n  sigma.x   sigma.y \n1.4763217 0.9063352 \n\nbw_ppl &lt;- bw.ppl(destination_ppp_sg.km)\nbw_ppl\n\n    sigma \n0.1913655 \n\n\n\nWe notice that bw_diggle, bw_CvL and bw_ppl all give a numeric sigma value, whereas bw_scott, by default, provides a separate bandwidth for each coordinate axis. In the code output above, sigma.x = 1.4763217 and sigma.y = 0.9063352 are the estimated bandwidths for the x and y coordinates, respectively. These values represent the amount of smoothing applied in each direction when estimating the kernel density.\nWe can specify isotropic=TRUE argument when calculating bw_scott() method to produce a single value bandwidth.\n\n\nbw_scott_single &lt;- bw.scott(destination_ppp_sg.km, isotropic=TRUE)\nbw_scott_single \n\n   sigma \n1.156738 \n\n\nThe optimized bandwidth values generated from above methods belongs to the special class bw.optim. The plot function can be used to see the objective function for the optimisation that leads to the result.\n\npar(mfrow = c(1,2))\nplot(bw_diggle, xlim=c(-0.02,0.05), ylim=c(-60,200))\nplot(bw_CvL)\n\n\n\npar(mfrow = c(1,2))\nplot(bw_scott)\nplot(bw_ppl,  xlim=c(-1,5), ylim=c(70000,130000))\n\n\n\n\n\n\n7.3.2 Plotting Fixed-Bandwidth KDE Layers\nIn practice, there are no definite method to choose the KDE bandwidth. Many literature has outlined a diverse range of approaches for KDE bandwidth selection. According to Wolff and Asche (2009), the choice of bandwidth in many existing studies is mostly conducted by visually comparing different bandwidth setting.\nHence, we will now create KDE layers based on each bandwidth selection method and visualize them to have a better comparison of how distinct the resulting KDE layers are.\n\nkde_diggle &lt;- density(destination_ppp_sg.km, bw_diggle)\nkde_CvL &lt;- density(destination_ppp_sg.km, bw_CvL)\nkde_scott &lt;- density(destination_ppp_sg.km, bw_scott)\nkde_ppl &lt;- density(destination_ppp_sg.km, bw_ppl)\n\npar(mar = c(1,1,1,1.5),mfrow = c(2,2))\nplot(kde_diggle,main = \"kde_diggle\")\nplot(kde_CvL,main = \"kde_CvL\")\nplot(kde_scott,main = \"kde_scott\")\nplot(kde_ppl,main = \"kde_ppl\")\n\n\n\n\nNext, we will try to plot histograms to compare the distribution of KDE values obtained from density() function using different bandwidth selection methods.\n\npar(mar = c(2,2,2,2),mfrow = c(2,2))\nhist(kde_diggle,main = \"kde_diggle\")\nhist(kde_CvL,main = \"kde_CvL\")\nhist(kde_scott,main = \"kde_scott\")\nhist(kde_ppl,main = \"kde_ppl\")\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nWe can interpret the outputs as below:\n\nkde_diggle: The sharp peak at the beginning indicates that the Diggle method for bandwidth selection has indentified a high concentration of points in the first bin. The rest of the bins has little to no concentration. This may suggest that one specific area in our observation window has observed a relatively high spatial clustering than the rest of the window.\nkde_CvL: The more balanced distribution suggests that the CvL method for bandwidth selection is identifying a broader range of spatial point concentration. However, the bin sizes are quite small, which smooths out the overall distribution and masks some of the finer details.\nkde_scott: The wider range of values and less sharp peak compared to kde_diggle indicate that the Scott method is capturing a wider range of spatial point concentrations, including both densely concentrated locations and moderately concentrated ones.\nkde_ppl: The result is very similar to the Diggle method, the sharp peak at the beginning suggests a high concentration of points in a specific area, suggest that one specific area in our observation window has observed a relatively high spatial clustering than the rest of the area.\n\n\n\nAnother apporach to compare the KDE layers is to calculate the standard error of each density estimation. $SE is used to extract the standard error of the density estimate from the output of the density() function\n\ndse_diggle &lt;- density(destination_ppp_sg.km, bw_diggle, se=TRUE)$SE\ndse_CvL &lt;- density(destination_ppp_sg.km, bw_CvL, se=TRUE)$SE\ndse_scott &lt;- density(destination_ppp_sg.km, bw_scott, se=TRUE)$SE\ndse_ppl &lt;- density(destination_ppp_sg.km, bw_ppl, se=TRUE)$SE\n\n\npar(mar = c(1,1,1,1.5),mfrow = c(2,2))\nplot(dse_diggle,main = \"standard error_diggle\")\nplot(dse_CvL,main = \"standard error_CvL\")\nplot(dse_scott,main = \"standard error_scott\")\nplot(dse_ppl,main = \"standard error_ppl\")\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe standard error (SE) of the density estimate provides a measure of the uncertainty associated with the density estimate at each point. This can be useful for understanding the variability of density estimates, especially when comparing density estimates obtained using different bandwidths.\nHowever, in many applications of KDE, the focus is often on the shape of the density estimate rather than its absolute value. In such cases, the standard error might not be as relevant. Hence, in this analysis, we will not use standard error as a criteria for choosing the bandwidth.\n\n\n\n\n7.3.3 Choosing Fixed KDE Bandwidth Selection Method\nUpon the exploration of various fixed bandwidth selection methods for computing KDE vales, and subsequent plotting of the respective KDE estimates, their distributions and associated standard errors, we will now select the KDE bandwidth to be used in our analysis. As we have seen in Section 7.3.1.2, each KDE bandwidth method has produced a distinct KDE and there is no definite method to choose the KDE bandwidth.\nWe will proceed to choose bw_scott method for further analysis. This is because:\n\nbw_scott method provides a pair of bandwidth values for each coordinate axis. This allows it to capture the different levels of spatial clustering in each direction more accurately.\nbw_scott method capture the balance between bias and variance the best among all methods. If the bandwidth is too small, the estimate may be too skewed (high variance). The distribution histograms of KDE layers using bw_diggle and bw_ppl tend to indicate such nature. On the other hand, if the bandwidth is too large, the estimate may be oversmoothed, missing crucial elements of the point pattern (high bias). This is what we observed in the distribution histogram of KDE layer using bw_CvL.\n\nSince we have chosen to use bw_scott method, now we will plot the KDE layer using this method for further analysis.\n\npar(mar = c(0,1,1,1))\nbw_fixed_scott &lt;- bw.scott(destination_ppp_sg.km)\nbw_fixed_scott\n\n  sigma.x   sigma.y \n1.4763217 0.9063352 \n\nkde_fixed_scott &lt;- density(destination_ppp_sg.km, bw_fixed_scott)\nplot(kde_fixed_scott,main = \"Fixed-Bandwidth KDE for Grab Destination Points (Using bw_scott)\")\ncontour(kde_fixed_scott, add=TRUE)\n\n\n\n\nHowever, upon visual inspection, there are signs of a certian degree of over-smoothing when we directly use the bandwidth provide by bw_scott method. Automatic bandwidth selection methods provides a starting point for bandwidth selection, and further fine-tuning might be necessary based on the results of the plot we have created above.\nTo do so, we will use rule of thumb adjustment by diving the bandwidth value by 2, to reduce the bandwidth size, and hence possible over-smoothing effect.\n\npar(mar = c(0,1,1,1))\nkde_fixed_scott &lt;- density(destination_ppp_sg.km, sigma=bw_fixed_scott/2)\nplot(kde_fixed_scott,main = \"Fixed-Bandwidth KDE for Grab Destination Points (Using bw_scott)\")\ncontour(kde_fixed_scott, add=TRUE)\n\n\n\n\nLooking at the plot created, it appears that by reducing the bandwidth (thus making the point cluster buffers smaller), the over-smoothing effects have been minimized. However, we still can observe the Grab destination hotspot areas, which we can investigate further in subsequent sections.\n\n\n7.3.4 Kernel Function Selection for Fixed Bandwidth\nKernel functions are important because they control how we weight points within the radius. The default kernel in density.ppp() is the gaussian. But there are other options. We can use the epanechnikov, quartic or disc.\n\ngaussian\nepanechnikov\nquartic\ndisc\n\n\nkde_fixed_scott.gaussian &lt;- density(destination_ppp_sg.km, \n                          sigma=bw_fixed_scott, \n                          edge=TRUE, \n                          kernel=\"gaussian\")\n\n\nkde_fixed_scott.epanechnikov &lt;- density(destination_ppp_sg.km, \n                          sigma=bw_fixed_scott, \n                          edge=TRUE, \n                          kernel=\"epanechnikov\")\n   \nkde_fixed_scott.quartic &lt;- density(destination_ppp_sg.km, \n                          sigma=bw_fixed_scott, \n                          edge=TRUE, \n                          kernel=\"quartic\")\n       \n   \nkde_fixed_scott.disc &lt;- density(destination_ppp_sg.km, \n                          sigma=bw_fixed_scott, \n                          edge=TRUE, \n                          kernel=\"disc\")\n         \npar(mar = c(1,1,1,1.5),mfrow = c(2,2))\nplot(kde_fixed_scott.gaussian, main=\"Gaussian\")\nplot(kde_fixed_scott.epanechnikov, main=\"Epanechnikov\")\nplot(kde_fixed_scott.quartic, main=\"Quartic\")\nplot(kde_fixed_scott.disc, main=\"Disc\")\n\n\n\n\n\n\n\n7.4 Creating KDE Layers with Spatially Adaptive Bandwidth\nFixed bandwidth kernels are commonly employed in statistical literature due to their ease of implementation. However, their application in spatial datasets often yields suboptimal estimations due to a lack of spatial and temporal adaptability (González & Moraga, 2022). Consequently, the more intuitive ‘adaptive smoothing’ approach has emerged. In this technique, the amount of smoothing is inversely related to the density of the points.\nIn spatstat packages, there are three main approaches (Pebesma & Bivand, 2023) in creating KDE layers with spatially adapative bandwidth.\n\nVoronoi-Dirichlet Adaptive Density Estimate: It computes the intensity function estimate of a point pattern dataset by creating tessellations. On default, the input point pattern data is used to construct a Voronoi/Dirichlet tessellation (Barr and Schoenberg, 2010). The intensity estimate at a given location equals the reciprocal of the size of the Voronoi/Dirichlet cell containing that location.\nAdaptive Kernel Density Estimate: It computes an estimate of the intensity function of a point pattern dataset using the partitioning technique of Davies and Baddeley (2018). It dynamically specifies the smoothing bandwidth to be applied to each of the points. The partitioning method of Davies and Baddeley (2018) accelerates this computation by partitioning the range of bandwidths into n-groups intervals, correspondingly subdividing the point patterns into n-groups, sub-patterns according to bandwidth, and applying fixed-bandwidth smoothing to each sub-pattern.\nNearest-Neighbour Adaptive Density Estimate: It computes an estimate of the intensity function of a point pattern dataset using the distance from each spatial location to the kth nearest points (Cressie, 1991: Silverman, 1986;Burman & Nolan, 1989). The default value of k is the square root of the number of points in the dataset. This estimator of intensity is relatively fast to compute and is spatially adaptive. Some studies suggest the use of the nearest neighbor distance as a suitable parameter for determining the bandwidth (Krisp et al., 2009).\n\n\n7.4.1 Voronoi-Dirichlet Adaptive Density Estimate\nThe Dirichlet-Voronoï estimator is computed in spatstat by the function adaptive.density() with argument method=\"voronoi\".\n\nkde_destination_dirichlet_adaptive &lt;- adaptive.density(destination_ppp_sg.km, f=1, method = \"voronoi\")\n\n\npar(mar = c(0,1,1,1))\nplot(kde_destination_dirichlet_adaptive,main = \"Voronoi-Dirichlet Adaptive Density Estimate\")\n\n\n\n\n\n\n7.4.2 Adaptive Kernel Density Estimate\nThe Adaptive Kernel estimator is computed in spatstat by the function adaptive.density() with argument method=\"kernel\".\n\nkde_destination_kernel_adaptive &lt;- adaptive.density(destination_ppp_sg.km, method = \"kernel\")\n\n\npar(mar = c(0,1,1,1))\nplot(kde_destination_kernel_adaptive,main = \"Adaptive Kernel Density Estimate\")\n\n\n\n\n\n\n7.4.3 Nearest-Neighbour Density Estimate\nThe Nearest-Neighbour estimator is computed in spatstat by the function nndensity().\n\nkde_adaptive_nn &lt;- nndensity(destination_ppp_sg.km, k=10)\n\n\npar(mar = c(0,1,1,1))\nplot(kde_adaptive_nn,main = \"Nearest-Neighbour Adaptive Density Estimate\")\n\n\n\n\n\n\n7.4.3 Choosing Adaptive KDE Method\nSimilar to what we did for fixed bandwidth, we can try to plot histograms to compare the distribution of KDE values obtained from density() function using different adaptive bandwidth selection methods.\n\npar(mar = c(2,2,2,2),mfrow = c(2,2))\nhist(kde_destination_dirichlet_adaptive,main = \"Voronoi-Dirichlet Adaptive\")\nhist(kde_destination_kernel_adaptive,main = \"Adaptive Kernel\")\nhist(kde_adaptive_nn,main = \"Nearest-Neighbour Adaptive\")\n\n\n\n\nFrom the outputs, it seems that there is no significance difference between the distribution of KDE values obtained across different methods. All three methods identified a high concentration of points in a specific area. Hence, we will choose to go with Adapative Kernel method because it provides the most\n\n\n\n7.5 Plotting Interactive KDE Maps\n\nraster_kde_fixed_scott &lt;- raster(kde_fixed_scott)\nraster_kde_adaptive_nn &lt;- raster(kde_adaptive_nn)\nraster_kde_adaptive_kernel &lt;- raster(kde_destination_kernel_adaptive)\n\n\nprojection(raster_kde_fixed_scott) &lt;- CRS(\"+init=EPSG:3414 +units=km\")\nprojection(raster_kde_adaptive_nn) &lt;- CRS(\"+init=EPSG:3414 +units=km\")\nprojection(raster_kde_adaptive_kernel) &lt;- CRS(\"+init=EPSG:3414 +units=km\")\n\n\ntmap_mode('view')\nkde_fixed_scott &lt;- tm_basemap(server = \"OpenStreetMap.HOT\") +\n  tm_basemap(server = \"Esri.WorldImagery\") +\n  tm_shape(raster_kde_fixed_scott) +\n  tm_raster(\"layer\",\n            n = 10,\n            title = \"KDE_Fixed_scott\",\n            alpha = 0.6,\n            palette = c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\")) +\n  tm_shape(mpsz_sf)+\n  tm_polygons(alpha=0.1,id=\"PLN_AREA_N\")+\n  tmap_options(check.and.fix = TRUE)\n\ntmap_mode('view')\nkde_adaptive_nn &lt;- tm_basemap(server = \"OpenStreetMap.HOT\") +\n  tm_basemap(server = \"Esri.WorldImagery\") +\n  tm_shape(raster_kde_adaptive_nn) +\n  tm_raster(\"layer\",\n            n = 7,\n            title = \"KDE_Adaptive_nn\",\n            style = \"pretty\",\n            alpha = 0.6,\n            palette = c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\")) +\n  tm_shape(mpsz_sf)+\n  tm_polygons(alpha=0.1,id=\"PLN_AREA_N\")+\n  tmap_options(check.and.fix = TRUE)\n\ntmap_mode('view')\nkde_adaptive_kernel &lt;- tm_basemap(server = \"OpenStreetMap.HOT\") +\n  tm_basemap(server = \"Esri.WorldImagery\") +\n  tm_shape(raster_kde_adaptive_kernel) +\n  tm_raster(\"layer\",\n            n = 7,\n            title = \"KDE_Adaptive_Kernel\",\n            style = \"pretty\",\n            alpha = 0.6,\n            palette = c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\")) +\n  tm_shape(mpsz_sf)+\n  tm_polygons(alpha=0.1,id=\"PLN_AREA_N\")+\n  tmap_options(check.and.fix = TRUE)\n\ntmap_arrange(kde_fixed_scott, kde_adaptive_nn, kde_adaptive_kernel ,ncol=1,nrow=3,sync = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.6 Planning Area-Level Kernel Density Estimation\n\nwl= mpsz_sf %&gt;% filter(PLN_AREA_N == \"WOODLANDS\")\nje = mpsz_sf %&gt;% filter(PLN_AREA_N == \"JURONG EAST\")\njw = mpsz_sf %&gt;% filter(PLN_AREA_N == \"JURONG WEST\")\ntn = mpsz_sf %&gt;% filter(PLN_AREA_N == \"TAMPINES\")\ntp = mpsz_sf %&gt;% filter(PLN_AREA_N == \"TOA PAYOH\")\npg = mpsz_sf %&gt;% filter(PLN_AREA_N == \"PUNGGOL\")\n\n\npar(mar = c(1,1,1,0),mfrow=c(2,3))\nplot(st_geometry(wl), main = \"Punggol\")\nplot(st_geometry(je), main = \"Jurong East\")\nplot(st_geometry(jw), main = \"Jurong West\")\nplot(st_geometry(tn), main = \"Tampines\")\nplot(st_geometry(tp), main = \"Toa Payoh\")\nplot(st_geometry(pg), main = \"Punggol\")\n\n\n\n\n\nwl_owin = as.owin(wl)\nje_owin = as.owin(je)\njw_owin = as.owin(jw)\ntn_owin = as.owin(tn)\ntp_owin = as.owin(tp)\npg_owin = as.owin(pg)\n\ndestination_wl_ppp = destination_ppp_sg[wl_owin]\ndestination_je_ppp = destination_ppp_sg[je_owin]\ndestination_jw_ppp = destination_ppp_sg[jw_owin]\ndestination_tn_ppp = destination_ppp_sg[tn_owin]\ndestination_tp_ppp = destination_ppp_sg[tp_owin]\ndestination_pg_ppp = destination_ppp_sg[pg_owin]\n\n\nwl_kde_scott &lt;- density(destination_wl_ppp, sigma=bw.scott, main=\"Woodlands\")\nje_kde_scott &lt;- density(destination_je_ppp, sigma=bw.scott, main=\"Jurong East\")\njw_kde_scott &lt;- density(destination_jw_ppp, sigma=bw.scott, main=\"Jurong West\")\ntn_kde_scott &lt;- density(destination_tn_ppp, sigma=bw.scott, main=\"Tampines\")\ntp_kde_scott &lt;- density(destination_tp_ppp, sigma=bw.scott, main=\"Toa Payoh\")\npg_kde_scott &lt;- density(destination_pg_ppp, sigma=bw.scott, main=\"Punggol\")\n\npar(mar = c(1,1,1,1.5),mfrow = c(3,2))\n\nplot(wl_kde_scott,main = \"KDE Woodlands\")\ncontour(wl_kde_scott, add=TRUE)\nplot(je_kde_scott,main = \"KDE Jurong East\")\ncontour(je_kde_scott, add=TRUE)\nplot(jw_kde_scott,main = \"KDE Jurong West\")\ncontour(jw_kde_scott, add=TRUE)\nplot(tn_kde_scott,main = \"KDE Tampines\")\ncontour(tn_kde_scott, add=TRUE)\nplot(tp_kde_scott,main = \"KDE Toa Payoh\")\ncontour(tp_kde_scott, add=TRUE)\nplot(pg_kde_scott,main = \"KDE Punggol\")\ncontour(pg_kde_scott, add=TRUE)\n\n\n\n\n\n\n7.0 Spatial Randomness Test\nClark and Evans (1954) give a very simple test of spatial randomness called Clark and Evans aggregation index (R). It is the ratio of the observed mean nearest neighbour distance in the pattern to that expected for a Poisson point process of the same intensity. A value R&gt;1 suggests ordering, while R&lt;1 suggests clustering.\nwe will perform the Clark-Evans test of aggregation for a spatial point pattern by using clarkevans.test() of statspat.\nThe test hypotheses are:\n\nH0 = The distribution of trajectory original points are randomly distributed.\nH1= The distribution of trajectory original points are not randomly distributed.\n\nThe 95% confidence interval will be used.\n\nclarkevans.test(origin_ppp_sg,\n                correction=\"none\",\n                clipregion=\"sg_owin\",\n                alternative=c(\"clustered\"),\n                nsim=99)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  origin_ppp_sg\nR = 0.27408, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)\n\n\nThe test hypotheses are:\n\nH0 = The distribution of trajectory destination points are randomly distributed.\nH1= The distribution of trajectory destination points are not randomly distributed.\n\nThe 95% confidence interval will be used.\n\nclarkevans.test(destination_ppp_sg,\n                correction=\"none\",\n                clipregion=\"sg_owin\",\n                alternative=c(\"clustered\"),\n                nsim=99)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  destination_ppp_sg\nR = 0.29484, p-value &lt; 2.2e-16\nalternative hypothesis: clustered (R &lt; 1)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#network-constrained-kernel-density-estimation-nkde",
    "href": "Take-home_Ex/Take-home_Ex01.html#network-constrained-kernel-density-estimation-nkde",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "8.0 Network Constrained Kernel Density Estimation (NKDE)",
    "text": "8.0 Network Constrained Kernel Density Estimation (NKDE)\nIn the real world, point events are often not randomly distributed. Instead, their distribution is constrained by networks. When carrying out spatial point pattern analysis, traditional Kernel Density Estimation (KDE) assumes an infinite, homogeneous, two-dimensional space, an approximation that is not accurate for network-based study areas. In such networks, movement is constrained by multiple one-dimensional lines (Gelb, 2021). Network Constrained Kernel Density Estimation (NKDE), therefore, is a widely used approach to identify the hotspots and evaluate origin-destination points along with the road network (Shen et al. 2020).\nThis approach estimates the intensity of the spatial process solely on the network. The network edges are divided into lixels (one-dimensional pixels), and the centers of the lixels serve as the locations for intensity estimation. Distances between events and sampling points are calculated as the shortest path distances on the network, instead of Euclidean distances. This adjustment slightly modifies the intensity function from the classical KDE function. The adapted formula makes the interpretation straightforward: it “estimates the density over a linear unit” rather than an area unit.\nIn this section, we will follow-up on the six planning areas we identified in Section 7.6 and attempt to create NKDE maps using spNetwork package.\n\n8.1 Extracting Road Networks for Focus Planning Areas\nBefore we carry out the anlysis, we will extract relevant datasets required for calculating NKDE values in each planning area:\n\nroad network\ndestination points\n\n\nwl_network = st_intersection(sg_driving_sf,st_union(wl))\nje_network = st_intersection(sg_driving_sf,st_union(je))\njw_network = st_intersection(sg_driving_sf,st_union(jw))\ntn_network = st_intersection(sg_driving_sf,st_union(tn))\ntp_network = st_intersection(sg_driving_sf,st_union(tp))\npg_network = st_intersection(sg_driving_sf,st_union(pg))\n\n\nwl_destination = st_intersection(destination_sf,st_union(wl))\nje_destination = st_intersection(destination_sf,st_union(je))\njw_destination = st_intersection(destination_sf,st_union(jw))\ntn_destination = st_intersection(destination_sf,st_union(tn))\ntp_destination = st_intersection(destination_sf,st_union(tp))\npg_destination = st_intersection(destination_sf,st_union(pg))\n\n\ntmap_mode(\"plot\")\ntm_shape(st_union(wl)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(wl_destination) + \n  tm_dots() + \ntm_shape(wl_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Woodlands\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\ntm_shape(st_union(je)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(je_destination) + \n  tm_dots() + \ntm_shape(je_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Jurong East\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\ntm_shape(st_union(jw)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(jw_destination) + \n  tm_dots() + \ntm_shape(jw_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Jurong West\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\ntm_shape(st_union(tn)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(tn_destination) + \n  tm_dots() + \ntm_shape(tn_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Tampines\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\ntm_shape(st_union(tp)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(tp_destination) + \n  tm_dots() + \ntm_shape(tp_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Toa Payoh\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\npg_network\n\ntm_shape(st_union(tp)) +\n  tm_polygons(col=\"white\") +\n  tm_shape(pg_destination) + \n  tm_dots() + \ntm_shape(pg_network) +\n  tm_lines(col=\"fclass\", palette =\"Spectral\") +\n  tm_layout(main.title = \"Road Network and Destination Points in Punggol\",\n            main.title.position = \"center\",\n            main.title.size = 0.9,\n            legend.outside = TRUE,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5)\n\n\n\n8.3 Data Preparation\n\nFor illustrative purpose, I’ll use “Punggol” as a example to demonstrate step-by-step data preparation process. Upon completion of this demonstration, maps for the remaining planning areas will be created.\n\nThe spNetwork package contains nkde function that is specifically designed to implement Network Constrained Kernel Density Estimation (NetKDE).\nThe three main inputs are: - lines, a “SpatialLinesDataFrame” (object defined in the sp package), representing the lines of the network. - events, a “SpatialPointsDataframe” (object defined in the sp package), representing the realizations of the spatial process. - samples, a “SpatialPointsDataframe” providing the locations where the density must be estimated.\n\n8.3.1 Preparing the lixels objects\nBefore computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork\n\npg_lixels &lt;- lixelize_lines(pg_network, \n                         700, \n                         mindist = 350)\n\n\nThe length of a lixel, lx_length is set to 700m, and\nThe minimum length of a lixel, mindist is set to 350m.\n\nAfter cut, if the length of the final lixel is shorter than the minimum distance, then it is added to the previous lixel. If NULL, then mindist = maxdist/10. Also note that the segments that are already shorter than the minimum distance are not modified.\n\n\n8.3.2 Generating line centre points\nNext, lines_center() of spNetwork will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points. The points are located at center of the line based on the length of the line.\n\npg_samples &lt;- lines_center(pg_lixels)\n\n\n\n\n8.4 Performing NKDE\n\n8.4.1 Computing Network Constrained Kernel Density Estimation\nThe spNetwork package offers three methods for calculating NKDE values simple, discontinuous and continuous.\n\nSimple NKDE: Simple NKDE method was proposed by Xie and Yan (2008), extending the planar KDE to a network-based model. However, there are issues with this method due to statistical incorrectness. Specifically, at network intersections, the event’s mass is multiplied in each direction, leading to overestimation and inflated density estimates, which can result in misleading interpretations (Gelb, 2021). To address these issues, Okabe et al. (2009) proposed two unbiased estimators: Discontinuous NKDE and Continuous NKDE.\nDiscontinuous NKDE: Discontinuous NKDE aims to resolve density inflation by dividing the mass at in-tersections according to the number of directions minus one, resulting in an unbiased estimator. However, the discontinuous nature of this method can be counter-intuitive in practical applications.\nContinuous NKDE: Continuous NKDE proposes to address the limitations of both simple and discontinuous NKDE. It adjusts the values of the NKDE at intersections and applies a backward correction to force the density values to be continuous.\n\nIn this analysis, we will compute NKDE values using all three methods and compare the results.\n\npg_nkde_simple &lt;- nkde(pg_network, \n                  events = pg_destination,\n                  w = rep(1,nrow(pg_destination)),\n                  samples = pg_samples,\n                  kernel_name = \"quartic\",\n                  bw = 200, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 5,\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\npg_nkde_discontinuous &lt;- nkde(pg_network, \n                  events = pg_destination,\n                  w = rep(1,nrow(pg_destination)),\n                  samples = pg_samples,\n                  kernel_name = \"quartic\",\n                  bw = 200, \n                  div= \"bw\", \n                  method = \"discontinuous\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 5,\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\npg_nkde_continuous &lt;- nkde(pg_network, \n                  events = pg_destination,\n                  w = rep(1,nrow(pg_destination)),\n                  samples = pg_samples,\n                  kernel_name = \"quartic\",\n                  bw = 200, \n                  div= \"bw\", \n                  method = \"continuous\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 5,\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\n\n\n“Reflection\n\n\n\nbw argument refers to the bandwidth used for calculating KDE values. Xie and Yan (2008) suggested that narrow bandwidths (between 20 and 250 m) are more appropriate for identifying local effects at smaller scales. Hence, we use 200 here.\nagg argument allows the events to be aggregated, and their weights to be added within a threshold distance. Aggregating events can simplify networks and limit the number of iterations when calculating the NKDE, hence effectively reducing time complexity of computation.\n\n\n\n\n8.4.1 Visualising NetKDE Maps Using Different Methods\nBefore we can visualise the NetKDE values, we will insert the computed density values into samples and lixels objects. To enhance the readability of the results, you will first multiply the obtained densities by the total number of drop-off points. This adjustment ensures that the spatial integral equals the number of events. Subsequently, you will multiply this value by 1000 to derive the estimated number of drop-off points per kilometer. This process will provide a more intuitive understanding of the density distribution along the network.\n\npg_samples$nkde_simple &lt;- pg_nkde_simple*nrow(pg_destination)*1000\npg_lixels$nkde_simple &lt;- pg_nkde_simple*nrow(pg_destination)*1000\n\npg_samples$nkde_discontinuous &lt;- pg_nkde_discontinuous*nrow(pg_destination)*1000\npg_lixels$nkde_discontinuous &lt;- pg_nkde_discontinuous*nrow(pg_destination)*1000\n\npg_samples$nkde_continuous &lt;- pg_nkde_continuous*nrow(pg_destination)*1000\npg_lixels$nkde_continuous &lt;- pg_nkde_continuous*nrow(pg_destination)*1000\n\nNow we can plot NKDE maps using tmap.\n\ntmap_mode('view')\npg_nkde_simple_map &lt;- tm_basemap(server = \"Esri.WorldTopoMap\") +\n  tm_basemap(server = \"Esri.WorldGrayCanvas\")+\n  tm_basemap(server = \"OpenStreetMap\") +\ntm_shape(pg_lixels)+\n  tm_lines(col=\"nkde_simple\", lwd = 2, palette =c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\ntm_shape(pg_destination)+\n  tm_dots(size=0.01)\n\npg_nkde_discontinuous_map &lt;- tm_basemap(server = \"Esri.WorldTopoMap\") +\n  tm_basemap(server = \"Esri.WorldGrayCanvas\")+\n  tm_basemap(server = \"OpenStreetMap\") +\ntm_shape(pg_lixels)+\n  tm_lines(col=\"nkde_discontinuous\", lwd = 2, palette =c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\ntm_shape(pg_destination)+\n  tm_dots(size=0.01)\n\npg_nkde_continuous_map &lt;- tm_basemap(server = \"Esri.WorldTopoMap\") +\n  tm_basemap(server = \"Esri.WorldGrayCanvas\")+\n  tm_basemap(server = \"OpenStreetMap\") +\ntm_shape(pg_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\ntm_shape(pg_destination)+\n  tm_dots(size=0.01)\n\n\ntmap_arrange(pg_nkde_simple_map, pg_nkde_discontinuous_map, pg_nkde_continuous_map ,ncol=3,nrow=1,sync = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnalysis\n\n\n\nComparing Simple, Discontinuous and Continuous NKDE Maps\n\n\n\n\n\nUpon close examination to the intersection as shown above, we can clearly see the density inflation caused by simple NKDE method, as opposed to discontinuous and continuous methods. A comparison between the Discontinuous and Continuous NKDE maps reveals the disjointed nature of lixels resulting from the Discontinuous method, as indicated by the varying color bands representing each lixel segment. Out of all three maps, continuous NKDE map offers the most intuitive representation.\n\n\nWe can also compare with traditonal KDE as below.\n\nraster_pg_kde_scott = raster(pg_kde_scott)\nprojection(raster_pg_kde_scott) &lt;- CRS(\"+init=EPSG:3414 +units=km\")\n\ntmap_mode('view')\ntm_basemap(server = \"Esri.WorldGrayCanvas\") +\ntm_shape(raster_pg_kde_scott)+\n  tm_raster(\"layer\",\n            n = 7,\n            title = \"KDE_Adaptive_Kernel\",\n            style = \"pretty\",\n            alpha = 0.6,\n            palette = c(\"#fafac3\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))\n\n\n\n\n8.5 Plotting NetKDE for Other Planning Areas\n\ntmap_mode('plot')\ntn_nkde &lt;- tm_shape(tn_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fbd448\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\n  tm_layout(main.title = \"NKDE Map (Tampines)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            frame = TRUE)\n\ntp_nkde &lt;- tm_shape(tp_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fbd448\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\n   tm_layout(main.title = \"NKDE Map (Toa Payoh)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            frame = TRUE)\n\nwl_nkde &lt;- tm_shape(wl_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fbd448\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\n  tm_layout(main.title = \"NKDE Map (Woodlands)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            frame = TRUE)\n\nje_nkde &lt;- tm_shape(je_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fbd448\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\n   tm_layout(main.title = \"NKDE Map (Jurong East)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            frame = TRUE)\n\njw_nkde &lt;- tm_shape(jw_lixels)+\n  tm_lines(col=\"nkde_continuous\", lwd = 2, palette =c(\"#fbd448\",\"#fd953b\",\"#f02a75\",\"#b62385\",\"#021c9e\"))+\n   tm_layout(main.title = \"NKDE Map (Jurong West)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.outside = TRUE,\n            frame = TRUE)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#temporal-network-kernel-density-estimation-tnkde",
    "href": "Take-home_Ex/Take-home_Ex01.html#temporal-network-kernel-density-estimation-tnkde",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "9.0 Temporal Network Kernel Density Estimation (TNKDE)",
    "text": "9.0 Temporal Network Kernel Density Estimation (TNKDE)\n\n9.1 Visualising Frequency Distribution\n\norigin_day &lt;- ggplot(data=origin_sf, \n              aes(x=weekday)) + \n              geom_bar()\n\ndestination_day &lt;-  ggplot(data=destination_sf, \n                    aes(x=weekday)) + \n                    geom_bar()\n\norigin_day + destination_day\n\n\n\n\n\n\n9.2 Plotting Frequency of Trip Origination By Hour\n\norigin_sf$pickup_hr_num &lt;- as.numeric(origin_sf$pickup_hr)\npickup_hr_num &lt;- origin_sf$pickup_hr_num\n\nggplot(data=origin_sf, \n                    aes(x=pickup_hr_num), bins = 24) + \n                    geom_bar() +\n    scale_x_continuous(breaks = pickup_hr_num)\n\n\n\n\n\n\n9.3 Plotting Frequency of Trip Destination By Hour\n\ndestination_sf$dropoff_hr_num &lt;- as.numeric(destination_sf$dropoff_hr)\ndropoff_hr_num &lt;- destination_sf$dropoff_hr_num\n\nggplot(data=destination_sf, \n                    aes(x=dropoff_hr_num), bins = 24) + \n                    geom_bar() +\n    scale_x_continuous(breaks = dropoff_hr_num)\n\n\n\n\n\n\n9.4 Bandwidth Selection\n\nw &lt;- rep(1,nrow(destination_sf))\nsamples &lt;- seq(0, max(destination_sf$dropoff_hr_num), 0.5)\n\nbw_bcv &lt;- bw.bcv(destination_sf$dropoff_hr_num)\nbw_ucv &lt;- bw.ucv(destination_sf$dropoff_hr_num)\nbw_SJ &lt;- bw.SJ(destination_sf$dropoff_hr_num)\n\ntime_kernel_values &lt;- data.frame(\n  bw_bcv = tkde(destination_sf$dropoff_hr_num, w = w, samples = samples, bw = bw_bcv, kernel_name = \"quartic\"),\n  bw_ucv = tkde(destination_sf$dropoff_hr_num, w = w, samples = samples, bw = bw_ucv, kernel_name = \"quartic\"),\n  bw_SJ = tkde(destination_sf$dropoff_hr_num, w = w, samples = samples, bw = bw_SJ, kernel_name = \"quartic\"),\n  time = samples\n)\n\ndf_time &lt;- reshape2::melt(time_kernel_values,id.vars = \"time\")\ndf_time$variable &lt;- as.factor(df_time$variable)\n\nggplot(data = df_time) + \n  geom_line(aes(x = time, y = value)) +\n  scale_x_continuous(breaks = dropoff_hr_num) +\n  facet_wrap(vars(variable), ncol=2, scales = \"free\")  + \n  theme(axis.text = element_text(size = 5))\n\n\n\n\n\n\n9.5 TNKDE Implementing at Punggol Planning Area\n\nw_pg &lt;- rep(1,nrow(pg_destination))\nsamples_pg &lt;- seq(0, max(pg_destination$dropoff_hr_num), 0.5)\n\nbw_bcv &lt;- bw.bcv(pg_destination$dropoff_hr_num)\nbw_ucv &lt;- bw.ucv(pg_destination$dropoff_hr_num)\nbw_SJ &lt;- bw.SJ(pg_destination$dropoff_hr_num)\n\ntime_kernel_values &lt;- data.frame(\n  bw_bcv = tkde(pg_destination$dropoff_hr_num, w = w_pg, samples = samples_pg, bw = bw_bcv, kernel_name = \"quartic\"),\n  bw_ucv = tkde(pg_destination$dropoff_hr_num, w = w_pg, samples = samples_pg, bw = bw_ucv, kernel_name = \"quartic\"),\n  bw_SJ = tkde(pg_destination$dropoff_hr_num, w = w_pg, samples = samples_pg, bw = bw_SJ, kernel_name = \"quartic\"),\n  time = samples_pg\n)\n\ndf_time &lt;- reshape2::melt(time_kernel_values,id.vars = \"time\")\ndf_time$variable &lt;- as.factor(df_time$variable)\n\nggplot(data = df_time) + \n  geom_line(aes(x = time, y = value)) +\n  scale_x_continuous(breaks = dropoff_hr_num) +\n  facet_wrap(vars(variable), ncol=2, scales = \"free\")  + \n  theme(axis.text = element_text(size = 5))\n\n\n\n\n\ncv_scores &lt;- bws_tnkde_cv_likelihood_calc(\n  bw_net_range = c(100,1000),\n  bw_net_step = 100,\n  bw_time_range = c(3,24),\n  bw_time_step = 3,\n  lines = pg_network,\n  events = pg_destination,\n  time_field = \"dropoff_hr_num\",\n  w = rep(1, nrow(pg_destination)),\n  kernel_name = \"quartic\",\n  method = \"discontinuous\", \n  diggle_correction = FALSE,\n  study_area = NULL,\n  max_depth = 10,\n  digits = 2,\n  tol = 0.1,\n  agg = 15,\n  sparse=TRUE,\n  grid_shape=c(1,1),\n  sub_sample=1,\n  verbose = FALSE,\n  check = TRUE)\n\n\nknitr::kable(cv_scores)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n6\n9\n12\n15\n18\n21\n24\n\n\n\n\n100\n-250.91794\n-182.71584\n-155.27632\n-116.78531\n-113.26649\n-102.39516\n-93.35400\n-89.81173\n\n\n200\n-145.76563\n-90.84170\n-69.02605\n-61.88347\n-56.56890\n-49.40677\n-49.57432\n-49.73512\n\n\n300\n-100.00061\n-65.40228\n-47.32325\n-43.88449\n-40.43182\n-36.94576\n-37.12520\n-37.29583\n\n\n400\n-68.95819\n-41.82902\n-32.92989\n-31.35903\n-29.73603\n-29.93138\n-30.11827\n-30.29386\n\n\n500\n-54.37326\n-34.65375\n-29.47804\n-29.75000\n-28.14349\n-28.34934\n-28.54072\n-28.71939\n\n\n600\n-47.21774\n-34.83465\n-29.69234\n-29.97549\n-28.37665\n-28.58649\n-28.77993\n-28.96001\n\n\n700\n-36.42261\n-29.55281\n-28.07569\n-28.36425\n-28.59379\n-28.80594\n-29.00069\n-29.18167\n\n\n800\n-32.88500\n-27.88168\n-28.25843\n-28.55089\n-28.79093\n-29.00503\n-29.20083\n-29.38249\n\n\n900\n-31.20502\n-28.04346\n-28.43185\n-28.72756\n-28.97115\n-29.18680\n-29.38338\n-29.56554\n\n\n1000\n-31.33948\n-28.19916\n-28.59400\n-28.89218\n-29.13776\n-29.35455\n-29.55170\n-29.73421\n\n\n\n\n\nAccording to the “leave one out cross validation” method, the optimal set of bandwidths is 800 metres and 6 hrs. As expected, larger bandwidths are required because the density of the events are spread both in space and time.\n\n# choosing sample in times (every 1 hr)\npg_sample_time &lt;- seq(0, max(pg_destination$dropoff_hr_num), 1.0)\n\n# calculating densities\ntnkde_densities &lt;- tnkde(lines = pg_network,\n                   events = pg_destination,\n                   time_field = \"dropoff_hr_num\",\n                   w = rep(1, nrow(pg_destination)), \n                   samples_loc = pg_samples,\n                   samples_time = pg_sample_time, \n                   kernel_name = \"quartic\",\n                   bw_net = 700, bw_time = 60,\n                   adaptive = TRUE,\n                   trim_bw_net = 900,\n                   trim_bw_time = 80,\n                   method = \"discontinuous\",\n                   div = \"bw\", max_depth = 10,\n                   digits = 2, tol = 0.01,\n                   agg = 15, grid_shape = c(1,1), \n                   verbose  = FALSE)\n\n\n# creating a color palette for all the densities\nlibrary(classInt)\nlibrary(viridis)\nall_densities &lt;- c(tnkde_densities$k)\ncolor_breaks &lt;- classIntervals(all_densities, n = 10, style = \"kmeans\")\n\n# generating a map at each sample time\nall_maps &lt;- lapply(1:ncol(tnkde_densities$k), function(i){\n  time &lt;- pg_sample_time[[i]]\n  \n  pg_samples$tnkde_density &lt;- tnkde_densities$k[,i]\n  map1 &lt;- tm_shape(pg_samples) + \n  tm_dots(col = \"tnkde_density\", size = 0.01,\n          breaks = color_breaks$brks, palette = viridis(10)) + \n    tm_layout(legend.show=FALSE, main.title = as.character(time), main.title.size = 0.5)\n  return(map1)\n})\n\n\n# creating a gif with all the maps\ntmap_animation(all_maps, filename = \"images/animated_ma.gif\", \n               width = 1000, height = 1000, dpi = 300, delay = 50)\n\n```"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01.html#references",
    "href": "Take-home_Ex/Take-home_Ex01.html#references",
    "title": "Take-Home Exercise 01: Spatial Point Patterns Analysis of Grab Trajectories in Singapore",
    "section": "References",
    "text": "References\nBaddeley, A., Rubak, E., & Turner, R. (2015). Spatial Point Patterns: Methodology and Applications with R (1st ed.). Chapman and Hall/CRC. https://doi.org/10.1201/b19708.\nBoots, B.N., & Getis, A. (1988). Point Pattern Analysis. Reprint. Edited by G.I. Thrall. WVU Research Repository.\nFloch, J.-M., Marcon, E., Puech, F. (n.d.). Spatial distribution of points. In M.-P. de Bellefon (Ed.), Handbook of Spatial Analysis : Theory and Application with R (pp. 72–111). Insee-Eurostat.\nGimond (2023). Chapter 11 Point Pattern Analysis. Retrieved from https://mgimond.github.io/Spatial/index.html.\nPebesma, E.; Bivand, R. (2023). Spatial Data Science: With Applications in R (1st ed.). Chapman and Hall/CRC. https://doi.org/10.1201/9780429459016.\nRey, S.J., Arribas-Bel, D., Wolf, L.J. (2023). Point Pattern Analysis. In: Geographic Data Science with python. CRC Press.\nWilkin, J. (2020). Geocomputation 2020-2021 Work Book. University College London. Retrieved from https://jo-wilkin.github.io/GEOG0030/coursebook/analysing-spatial-patterns-iii-point-pattern-analysis.html.\nYuan, Y., Qiang, Y., Bin Asad, K., and Chow, T. E. (2020). Point Pattern Analysis. In J.P. Wilson (Ed.), The Geographic Information Science & Technology Body of Knowledge (1st Quarter 2020 Edition). DOI: 10.22224/gistbok/2020.1.13.\nKam, T. S. (2022). R for Geospatial Data Science and Analytics. Retrieved from https://r4gdsa.netlify.app/"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03-NKDE.html",
    "href": "In-class_Ex/In-class_Ex03-NKDE.html",
    "title": "In-Class Exercise 03 NKDE",
    "section": "",
    "text": "Network constrained Spatial Point Patterns Analysis (NetSPAA) is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network. The spatial point event can be locations of traffic accident or childcare centre for example. The network, on the other hand can be a road network or river network.\nIn this hands-on exercise, you are going to gain hands-on experience on using appropriate functions of spNetwork package:\n\nto derive network constrained kernel density estimation (NetKDE), and\nto perform network G-function and k-function analysis"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03-NKDE.html#overview",
    "href": "In-class_Ex/In-class_Ex03-NKDE.html#overview",
    "title": "In-Class Exercise 03 NKDE",
    "section": "",
    "text": "Network constrained Spatial Point Patterns Analysis (NetSPAA) is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network. The spatial point event can be locations of traffic accident or childcare centre for example. The network, on the other hand can be a road network or river network.\nIn this hands-on exercise, you are going to gain hands-on experience on using appropriate functions of spNetwork package:\n\nto derive network constrained kernel density estimation (NetKDE), and\nto perform network G-function and k-function analysis"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03-NKDE.html#installing-and-launching-the-r-package",
    "href": "In-class_Ex/In-class_Ex03-NKDE.html#installing-and-launching-the-r-package",
    "title": "In-Class Exercise 03 NKDE",
    "section": "2.0 Installing and launching the R package",
    "text": "2.0 Installing and launching the R package\nIn this hands-on exercise, four R packages will be used, they are:\n\nspNetwork, which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.\nrgdal, which provides bindings to the ‘Geospatial’ Data Abstraction Library (GDAL) (&gt;= 1.11.4) and access to projection/transformation operations from the PROJ library. In this exercise, rgdal will be used to import geospatial data in R and store as sp objects.\nsp, which provides classes and methods for dealing with spatial data in R. In this exercise, it will be used to manage SpatialPointsDataFrame and SpatiaLinesDataFrame, and for performing projection transformation.\ntmap which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.\n\n\npacman::p_load(sf, spNetwork, tmap, classInt, virdis, tidyverse)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03-NKDE.html#importing-data-to-r-environment",
    "href": "In-class_Ex/In-class_Ex03-NKDE.html#importing-data-to-r-environment",
    "title": "In-Class Exercise 03 NKDE",
    "section": "3.0 Importing Data to R Environment",
    "text": "3.0 Importing Data to R Environment\nIn this study, we will analyse the spatial distribution of childcare centre in Punggol planning area. For the purpose of this study, two geospatial data sets will be used. They are:\n\nPunggol_St, a line features geospatial data which store the road network within Punggol Planning Area.\nPunggol_CC, a point feature geospatial data which store the location of childcare centres within Punggol Planning Area.\n\nBoth data sets are in ESRI shapefile format.\n\nnetwork &lt;- st_read(dsn=\"../data/geospatial\", \n                   layer=\"Punggol_St\")\n\nReading layer `Punggol_St' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 2642 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 34038.56 ymin: 40941.11 xmax: 38882.85 ymax: 44801.27\nProjected CRS: SVY21 / Singapore TM\n\nchildcare &lt;- st_read(dsn=\"../data/geospatial\",\n                     layer=\"Punggol_CC\")\n\nReading layer `Punggol_CC' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 61 features and 1 field\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 34423.98 ymin: 41503.6 xmax: 37619.47 ymax: 44685.77\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\n\n\nNext, we will plot the childcare locations (as points) and road network (as lines) as follows.\n\ntmap_mode('view')\ntm_shape(childcare)+\n  tm_dots(col='orange')+\n  tm_shape(network)+\n  tm_lines()\n\n\n\n\n\ntmap_mode('plot')"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03-NKDE.html#network-constrained-kde-netkde-analysis",
    "href": "In-class_Ex/In-class_Ex03-NKDE.html#network-constrained-kde-netkde-analysis",
    "title": "In-Class Exercise 03 NKDE",
    "section": "4.0 Network Constrained KDE (NetKDE) Analysis",
    "text": "4.0 Network Constrained KDE (NetKDE) Analysis\n\n4.1 Preparing the lixels objects\nBefore computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork as shown in the code chunk below.\n\n\nlixels &lt;- lixelize_lines(network, 750, mindist = 375)\n\n\n\n4.2 Generating Line Centers\nNext, we will used lines_center() of spNetwork to generate a SpatialPointsDataFrame (i.e. samples) with line centre points.\n\nsamples &lt;- lines_center(lixels)\n\n\n\n4.3 Performing NKDE\nOnce we have obtained all the datasets required, we can perform NKDE by using nkde() function of spNetwork.\n\ndensities &lt;- nkde(network, \n                  events = childcare,\n                  w = rep(1,nrow(childcare)),\n                  samples = samples,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 5,\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n4.4 Visualisation\n\nsamples$density &lt;- densities\nlixels$density &lt;- densities\n\nNext, we will rescale the density values to help with better mapping results\n\nsamples$density &lt;- samples$density*1000\nlixels$density &lt;- lixels$density*1000\n\n\ntmap_mode('view')\ntm_shape(lixels)+\n  tm_lines(col=\"density\", palette=\"plasma\")+\ntm_shape(childcare)+\n  tm_dots()\n\n\n\n\n\ntmap_mode('plot')\n\nThe interactive map above effectively reveals road segments (darker color) with relatively higher density of childcare centres than road segments with relatively lower density of childcare centres (lighter color)\nIn practical use, we can use these results to effectively identify areas where new pedestrian roads can be built."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex02.html",
    "href": "In-class_Ex/In-class_Ex02.html",
    "title": "In-Class Exercise 02",
    "section": "",
    "text": "In this exercise, we will explore how to process and wrangle Grab Posisi dataset."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex02.html#overview",
    "href": "In-class_Ex/In-class_Ex02.html#overview",
    "title": "In-Class Exercise 02",
    "section": "",
    "text": "In this exercise, we will explore how to process and wrangle Grab Posisi dataset."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex02.html#importing-packages",
    "href": "In-class_Ex/In-class_Ex02.html#importing-packages",
    "title": "In-Class Exercise 02",
    "section": "2.0 Importing Packages",
    "text": "2.0 Importing Packages\nBefore we start the exercise, we will need to import necessary R packages first. We will use the following packages:\n\narrow for reading and writing Apache Parquet files\nlubridate for tackling with temporal data (dates and times)\ntidyverse for manipulating and wrangling data, as well as, implementing data science functions\ntmap for creating and visualizing thematic maps\nsf for handling geospatial data.\n\n\npacman::p_load(arrow,lubridate,tidyverse,tmap,sf)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex02.html#importing-datasets-into-r-environment",
    "href": "In-class_Ex/In-class_Ex02.html#importing-datasets-into-r-environment",
    "title": "In-Class Exercise 02",
    "section": "3.0 Importing Datasets into R Environment",
    "text": "3.0 Importing Datasets into R Environment\n\n3.1 Datasets\nIn this exercise, we will use Grab-Posisi dataset, which is a comprehensive GPS trajectory dataset for car-hailing services in Southeast Asia.\n\nApart from the time and location of the object, GPS trajectories are also characterised by other parameters such as speed, the headed direction, the area and distance covered during its travel, and the travelled time. Thus, the trajectory patterns from users GPS data are a valuable source of information for a wide range of urban applications, such as solving transportation problems, traffic prediction, and developing reasonable urban planning.\n\n\n3.1 Importing Grab-Posisi Dataset\nEach trajectory in Grab-Posisi dataset is serialised in a file in Apache Parquet format.\n\nFirstly, we will use read_parquet function from arrow package\n\n\ndf &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00000.snappy.parquet')\ndf_1 &lt;- read_parquet('~/IS415-GAA/data/GrabPosisi/part-00001.snappy.parquet')\n\n\nNext, we will use head() function to quickly scan through the data columns and values.\n\n\nhead(df)\n\n# A tibble: 6 × 9\n  trj_id driving_mode osname  pingtimestamp rawlat rawlng speed bearing accuracy\n  &lt;chr&gt;  &lt;chr&gt;        &lt;chr&gt;           &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 70014  car          android    1554943236   1.34   104.  18.9     248      3.9\n2 73573  car          android    1555582623   1.32   104.  17.7      44      4  \n3 75567  car          android    1555141026   1.33   104.  14.0      34      3.9\n4 1410   car          android    1555731693   1.26   104.  13.0     181      4  \n5 4354   car          android    1555584497   1.28   104.  14.8      93      3.9\n6 32630  car          android    1555395258   1.30   104.  23.2      73      3.9\n\n\nFrom the result above, we can see that the dataset includes a total of 9 columns as follows:\n\n\n\nColumn Name\nData Type\nRemark\n\n\n\n\ntrj_id\nchr\nTrajectory ID\n\n\ndriving_mode\nchr\nMode of Driving\n\n\nosname\nchr\n\n\n\npingtimestamp\nint\nData Recording Timestamp\n\n\nrawlat\nnum\nLatitude Value (WGS-84)\n\n\nrawlng\nnum\nLongitude Value (WGS-84)\n\n\nspeed\nnum\nSpeed\n\n\nbearing\nint\nBearing\n\n\naccuracy\nnum\nAccuracy\n\n\n\nFrom the above table, it is seen that the pingtimestamp is recorded as int. We need to convert this data to proper datetime format to derive meaningful temporal insights of the data. To do so, we will use as_datetime() function from lubridate package.\n\ndf$pingtimestamp &lt;- as_datetime(df$pingtimestamp)\n\n\n\n3.2 Extracting Trip Starting Locations and Temporal Data Values\nAfter loading the Grab-Posisi dataset, we will extract features that we want to use for analysis. Firstly, we will extract trip starting locations for all trajectories in the dataset and save it into a new df called origin_df.\nAlso, we are interested to derive useful temporal data such as day of the week, hour, and yy-mm-dd. To do so, we will use the following functions from lubridate package, and add the newly derived values as new columns to origin_df.\n\nwday: allows us to get days component of a date-time\nhour: allows us to get hours component of a date-time\nmday: allows us to parse dates with year, month, and day components\n\n\norigin_df &lt;- df %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(pingtimestamp) %&gt;%\n  filter(row_number()==1) %&gt;% \n  mutate(weekday = wday(pingtimestamp,\n                       label=TRUE,\n                       abbr=TRUE),\n         starting_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp)))\n\n\n\n3.3 Extracting Trip Ending Locations and Temporal Data Values\nSimilar to what we did in previous session, we are also interested to extract trip ending locations and associated temporal data into a new df called destination_df. We will use the same functions from previous session here.\n\ndestination_df &lt;- df %&gt;%\n  group_by(trj_id) %&gt;%\n  arrange(desc(pingtimestamp)) %&gt;%\n  filter(row_number()==1) %&gt;% \n  mutate(weekday = wday(pingtimestamp,\n                       label=TRUE,\n                       abbr=TRUE),\n         starting_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp)))\n\n\n\n\n\n\n\nReflection\n\n\n\narrange() function sort the timestamps in ascending order by default. Hence, for destination_df, we use arrange(desc()) argument to sort the timestamps in descending order\n\n\n\n\n3.4 Saving R Objects in RDS Format\nRDS (R Data Serialization) files are a common format for saving R objects in RStudio, and they allow us to preserve the state of an object between R sessions. Saving R object as an RDS file in R can be useful for sharing our work with others, replicating our analysis, or simply storing our work for later use.\n\nwrite_rds(origin_df, \"../data/rds/origin_df.rds\")\nwrite_rds(destination_df, \"../data/rds/destination_df.rds\")\n\n\n\n3.4 Importing RDS Objects\n\norigin_df &lt;- read_rds(\"../data/rds/origin_df.rds\")\ndestination_df &lt;- read_rds(\"../data/rds/destination_df.rds\")"
  },
  {
    "objectID": "data/geospatial/MPSZ-2019.html",
    "href": "data/geospatial/MPSZ-2019.html",
    "title": "IS415 - Geospatial with Khant",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03.html",
    "href": "In-class_Ex/In-class_Ex03.html",
    "title": "In-Class Exercise 03",
    "section": "",
    "text": "pacman::p_load(arrow,lubridate,tidyverse,tmap,sf)\n\n\ninstall.packages(\"maptools\", repos = \"https://packagemanager.posit.co/cran/2023-10-13\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03.html#importing-datasets-to-r-environment",
    "href": "In-class_Ex/In-class_Ex03.html#importing-datasets-to-r-environment",
    "title": "In-Class Exercise 03",
    "section": "3.0 Importing Datasets to R Environment",
    "text": "3.0 Importing Datasets to R Environment\nIn this exercise, we will use the following datasets:\n\nCHILDCARE, a point feature data providing both location and attribute information of childcare centres. It was downloaded from Data.gov.sg and is in geojson format.\nMP14_SUBZONE_WEB_PL, a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format. This data set was also downloaded from Data.gov.sg.\nCostalOutline, a polygon feature data showing the national boundary of Singapore. It is provided by SLA and is in ESRI shapefile format.\n\n\n3.1 Importing Geospatial Data\nIn this section, st_read() of sf package will be used to import the three geospatial data sets mentioned in previous section into R environment.\n\nchildcare_sf &lt;- st_read(\"../data/aspatial/child-care-services-geojson.geojson\")\n\nReading layer `child-care-services-geojson' from data source \n  `/Users/khantminnaing/IS415-GAA/data/aspatial/child-care-services-geojson.geojson' \n  using driver `GeoJSON'\nSimple feature collection with 1925 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\nmpsz_sf &lt;- st_read(dsn = \"../data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex03.html#geospatial-data-wrangling",
    "href": "In-class_Ex/In-class_Ex03.html#geospatial-data-wrangling",
    "title": "In-Class Exercise 03",
    "section": "4.0 Geospatial Data Wrangling",
    "text": "4.0 Geospatial Data Wrangling\n\n4.1. Assigning Stanadrd Coordinate Systems\n\nchildcare_sf &lt;- st_transform(childcare_sf, crs = 3414)\nmpsz_sf &lt;- st_transform(mpsz_sf, crs = 3414)\n\n\n\n4.2 Creating Coastal Outline\n\nsg_sf &lt;- mpsz_sf %&gt;% st_union()\nplot(sg_sf)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html",
    "href": "In-class_Ex/In-class_Ex04.html",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "Spatial weights are a key component in any cross-sectional analysis of spatial dependence. They are an essential element in the construction of spatial autocorrelation statistics, and provide the means to create spatially explicit variables, such as spatially lagged variables and spatially smoothed rates. Computing spatial weight is an essential step toward measuring the strength of the spatial relationships between objects. In this exercise, the basic concept of spatial weight will be introduced. This is followed by a discussion of methods to compute spatial weights. Particularly, we will explore using spdep and GWmodel.\n\n\n\nIn this hands-on exercise, we will use the following R package:\n\nsf\nsp\nspdep,\ntmap\ntidyverse\nknitr\nGWmodel\n\n\npacman::p_load(sf, sp, spdep, tmap, tidyverse, knitr, GWmodel)\n\n\n\n\nIn this exercise, we will use the following datasets:\n\nHunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv This csv file contains selected Hunan’s local development indicators in 2012.\n\n\n\nIn this section, st_read() of sf package will be used to import the three geospatial data sets mentioned in previous section into R environment.\n\nhunan &lt;- st_read(dsn = \"../data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n\nIn this section, read_csv() of sf package will be used to import the csv file into R environment. The output is R dataframe class.\n\nhunan2012 &lt;- read_csv(\"../data/aspatial/Hunan_2012.csv\")\nhunan2012\n\n# A tibble: 88 × 29\n   County    City   avg_wage deposite    FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO\n   &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 Anhua     Yiyang    30544   10967   6832.    457.   2703  13225  14567  9277.\n 2 Anren     Chenz…    28058    4599.  6386.    221.   1455.  4941. 12761  4189.\n 3 Anxiang   Chang…    31935    5517.  3541     244.   1780. 12482  23667  5109.\n 4 Baojing   Hunan…    30843    2250   1005.    193.   1379.  4088. 14563  3624.\n 5 Chaling   Zhuzh…    31251    8241.  6508.    620.   1947  11585  20078  9158.\n 6 Changning Hengy…    28518   10860   7920     770.   2632. 19886  24418 37392 \n 7 Changsha  Chang…    54540   24332  33624    5350    7886. 88009  88656 51361 \n 8 Chengbu   Shaoy…    28597    2581.  1922.    161.   1192.  2570. 10132  1681.\n 9 Chenxi    Huaih…    33580    4990   5818.    460.   1724.  7755. 17026  6644.\n10 Cili      Zhang…    33099    8117.  4498.    500.   2306. 11378  18714  5843.\n# ℹ 78 more rows\n# ℹ 19 more variables: Loan &lt;dbl&gt;, NIPCR &lt;dbl&gt;, Bed &lt;dbl&gt;, Emp &lt;dbl&gt;,\n#   EmpR &lt;dbl&gt;, EmpRT &lt;dbl&gt;, Pri_Stu &lt;dbl&gt;, Sec_Stu &lt;dbl&gt;, Household &lt;dbl&gt;,\n#   Household_R &lt;dbl&gt;, NOIP &lt;dbl&gt;, Pop_R &lt;dbl&gt;, RSCG &lt;dbl&gt;, Pop_T &lt;dbl&gt;,\n#   Agri &lt;dbl&gt;, Service &lt;dbl&gt;, Disp_Inc &lt;dbl&gt;, RORP &lt;dbl&gt;, ROREmp &lt;dbl&gt;\n\n\n\n\n\n\n\n\nIn previous section, we have imported a shapefile hunan representing the geographical boundaries of Hunan and a dataframe hunan2012 which contains the attribute fields corresponding to counties in Hunan.\nThe next step in our analysis involves updating the attribute table of the hunan shapefile with the values from hunan2012.\nHence, we will need to update the attribute table of Hunan by using left_join() of dplyr package. This function effectively merges the two datasets, ensuring that each county’s geographical data is accurately linked with its corresponding attribute data from the hunan2012 dataframe.\n\nhunan &lt;- left_join(hunan,hunan2012, join_by(County))%&gt;%\n  select(1:4, 7, 15)\n\n\n\n\n\nhunan_sp &lt;- hunan %&gt;% as_Spatial()\n\n\n\n\n\nThis function calculates basic and robust GWSS, including geographically weighted means, standard deviations and skew. Robust alternatives include geographically weighted medians, inter-quartile ranges and quantile imbalances. This function also calculates basic geographically weighted covariances together with basic and robust geographically weighted correlations.\n\ngwstat &lt;- gwss(data= hunan_sp,\n               vars = \"GDPPC\",\n               bw = 6,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\n\nWhat can we learn from this code chunk?\n\nThe data argument is set to hunan_sp, which means the data being used is stored in the hunan_sp variable.\nThe vars argument is set to \"GDPPC\". This indicates that the variable of interest in the hunan_sp data is \"GDPPC\".\nThe bw argument is set to 6. This is the bandwidth parameter for the geographical weighting, which controls the degree of smoothing.\nThe kernel argument is set to \"bisquare\". This means the bisquare kernel function is used for weighting.\nThe adaptive argument is set to TRUE, which means the bandwidth is adaptive. In other words, the bandwidth adjusts depending on the density of the data points.\nThe longlat argument is set to T (short for TRUE). This indicates that the data’s coordinates are in longitude and latitude.\n\n\ngwstat\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n\n   ***********************Calibration information*************************\n\n   Local summary statistics calculated for variables:\n    GDPPC\n   Number of summary points: 88\n   Kernel function: bisquare \n   Summary points: the same locations as observations are used.\n   Adaptive bandwidth: 6 (number of nearest neighbours)\n   Distance metric: Great Circle distance metric is used.\n\n   ************************Local Summary Statistics:**********************\n   Summary information for Local means:\nGDPPC_LM \n    Min.  1st Qu.   Median  3rd Qu.     Max. \n10313.11 17616.21 21981.39 28547.05 73545.30 \n   Summary information for local standard deviation :\nGDPPC_LSD \n      Min.    1st Qu.     Median    3rd Qu.       Max. \n  926.3095  3319.0782  5041.7997  7602.3637 24377.4421 \n   Summary information for local variance :\nGDPPC_LVar \n       Min.     1st Qu.      Median     3rd Qu.        Max. \n   858049.3  11030994.6  25419746.0  57798649.1 594259684.0 \n   Summary information for Local skewness:\nGDPPC_LSKe \n       Min.     1st Qu.      Median     3rd Qu.        Max. \n-3.74328455 -0.06903772  0.74202796  1.20539540  5.98374890 \n   Summary information for localized coefficient of variation:\nGDPPC_LCV \n      Min.    1st Qu.     Median    3rd Qu.       Max. \n0.04955751 0.15100369 0.22079470 0.33316203 0.95567593 \n\n   ************************************************************************\n\n\nThe output of the gwss() function is a SpatialPointsDataFrame (SDF). We can view the values inside this dataframe.\n\ngwstat_df &lt;- gwstat[[\"SDF\"]]@data\ngwstat_df\n\n   GDPPC_LM  GDPPC_LSD  GDPPC_LVar  GDPPC_LSKe  GDPPC_LCV\n1  26797.76  5368.4595  28820357.0  0.66633204 0.20033243\n2  21194.35  1698.0390   2883336.3  2.09614479 0.08011754\n3  27755.09  4825.3960  23284446.3  0.64707878 0.17385627\n4  27142.60  4146.6643  17194824.5  1.16119871 0.15277327\n5  27681.99  4332.3440  18769204.5  0.92967739 0.15650406\n6  24249.16  3670.7229  13474206.9 -0.85466668 0.15137523\n7  59246.71 22419.9966 502656247.4 -0.62939642 0.37841757\n8  50685.94 16702.7409 278981554.2 -0.86488843 0.32953402\n9  69729.10 15306.7753 234297370.2 -0.84589675 0.21951775\n10 19740.12  8635.5046  74571939.8  1.07796143 0.43745947\n11 24375.01 22290.1025 496848668.9  1.18483157 0.91446544\n12 29322.23  5962.4104  35550337.5 -1.88571194 0.20334096\n13 23969.10  5043.2717  25434589.3  0.56523820 0.21040723\n14 25383.12 24258.0380 588452406.9  1.03964154 0.95567593\n15 21816.34  5040.3276  25404902.6  1.04816353 0.23103455\n16 36359.36 16102.9533 259305105.8  0.56214571 0.44288329\n17 42389.06 24307.7075 590864643.0 -0.32129825 0.57344291\n18 23672.87  2642.5387   6983010.8 -2.57545765 0.11162733\n19 27607.43  3389.1128  11486085.5  1.50576400 0.12276090\n20 22223.48  1889.3881   3569787.4  0.97182679 0.08501764\n21 24679.04  2679.7697   7181165.8 -1.15519704 0.10858485\n22 26558.82  7204.3387  51902495.6  0.01029577 0.27125975\n23 19778.52  2879.7720   8293087.0  1.11653676 0.14560101\n24 18458.67  5484.3159  30077721.1  1.62822457 0.29711324\n25 23423.43  7021.5422  49302054.4  0.03116617 0.29976582\n26 16541.26  2397.1846   5746493.9  0.60063497 0.14492156\n27 16545.42  3392.6269  11509917.5  0.06849616 0.20504933\n28 15066.82  4122.0062  16990935.1  3.08938061 0.27358169\n29 14821.56  3662.2795  13412290.8  0.44253465 0.24709131\n30 16915.67  2471.5922   6108768.0  0.72194074 0.14611257\n31 15183.78  3588.4893  12877255.6  2.94946079 0.23633700\n32 21541.65  5069.4678  25699503.7 -1.43147322 0.23533329\n33 19601.11  3108.9744   9665722.0  0.50522382 0.15861214\n34 32412.12 24242.1346 587681090.0  0.53522173 0.74793418\n35 20599.49  4617.7969  21324048.0  1.19120123 0.22417046\n36 28859.13 23348.8623 545169370.5  0.85575588 0.80906328\n37 11984.64  2493.0666   6215381.2  0.86286370 0.20802177\n38 17861.63  4667.0959  21781784.0 -0.94299674 0.26129176\n39 12911.26  2058.7063   4238271.6  0.57312479 0.15945051\n40 10313.11  1358.4328   1845339.8  1.46878192 0.13171898\n41 22146.45  4918.0988  24187695.5 -1.25740463 0.22207165\n42 14975.46  2055.6929   4225873.1 -1.70732382 0.13727074\n43 12164.44  1245.7923   1551998.4  1.22251626 0.10241262\n44 13193.61  3927.1815  15422754.5  1.39569677 0.29765777\n45 28443.02 24377.4421 594259684.0  0.77640738 0.85706245\n46 47125.62 15312.7089 234479054.1 -0.27861152 0.32493383\n47 38611.99 14830.2228 219935507.2  0.36610524 0.38408332\n48 17657.75  5844.9396  34163319.0  1.30857144 0.33101270\n49 17491.60  6505.9155  42326936.2  1.45654920 0.37194513\n50 15515.46  7517.4264  56511699.0  1.54877539 0.48451204\n51 20510.72  6286.3751  39518511.4  0.76211517 0.30649211\n52 26867.31  6659.8455  44353542.2 -0.81626138 0.24787916\n53 10537.76  1827.5034   3339768.6  1.73988753 0.17342427\n54 21458.65  6410.2129  41090829.2  0.92850266 0.29872402\n55 11158.95  2038.4420   4155245.7  0.87994007 0.18267325\n56 17755.28 12355.3608 152654940.8  3.44850457 0.69586971\n57 24456.63  3410.7395  11633143.6  0.67835216 0.13946070\n58 26336.34  4277.4598  18296661.9  0.62670078 0.16241662\n59 16996.88  1726.1703   2979664.0  0.32191512 0.10155806\n60 21694.07  5586.4342  31208247.3  0.41714732 0.25750971\n61 13001.25  1283.9048   1648411.5  5.98374890 0.09875244\n62 18465.25  3787.5902  14345839.6 -0.53021537 0.20511986\n63 18303.20  7692.6257  59176489.7  1.19968844 0.42028858\n64 26403.02  3950.9600  15610084.7 -0.16628639 0.14964046\n65 29483.86  5240.6913  27464845.8 -0.03662150 0.17774779\n66 39627.60  5939.7432  35280549.4  2.79485609 0.14988906\n67 31222.95 20177.8114 407144072.6  1.17435721 0.64624938\n68 38729.57 13251.8288 175610966.4  1.87097064 0.34216308\n69 21023.94  4320.0698  18663002.8  0.33292211 0.20548333\n70 21779.33  7897.1802  62365454.8  0.84949897 0.36259973\n71 36145.76  7572.2763  57339368.9  0.60666792 0.20949281\n72 18320.55  7250.8272  52574495.5  2.82295265 0.39577568\n73 32111.38  6803.2988  46284874.5 -0.78168385 0.21186567\n74 31241.75  6281.7162  39459957.9  1.01170224 0.20106800\n75 14149.53  3479.5527  12107287.0  0.61165691 0.24591292\n76 30094.68  5357.3059  28700726.8  1.43635637 0.17801508\n77 20612.58  1021.5081   1043478.9 -1.22827158 0.04955751\n78 28030.22 16659.8549 277550765.8  1.55786400 0.59435324\n79 11568.42  4599.1330  21152024.5  2.42445803 0.39755941\n80 30072.20 20122.3972 404910869.5  1.07612199 0.66913621\n81 20798.53  6099.8177  37207775.7  0.91816728 0.29328120\n82 20711.07  2402.3836   5771447.0  1.04546797 0.11599516\n83 31736.24  3995.0473  15960402.8 -3.74328455 0.12588280\n84 73545.30 17307.2896 299542274.1 -0.94731806 0.23532827\n85 22871.95  1329.5897   1767808.8  3.12696176 0.05813188\n86 32486.94 11032.8903 121724668.1  1.59450531 0.33961003\n87 17429.45  2571.4590   6612401.6 -0.50838795 0.14753533\n88 17096.49   926.3095    858049.3 -0.68882538 0.05418127\n\n\nGDPPC_LM refers to local means\nGDPPC_LSD refers to local standard deviation\nGDPPC_LVar refers to local variance\nGDPPC_LSKe refers to local skew\nGDPPC_LCV refers to local coefficients of variation\n\n\n\ngwstat_df\n\n   GDPPC_LM  GDPPC_LSD  GDPPC_LVar  GDPPC_LSKe  GDPPC_LCV\n1  26797.76  5368.4595  28820357.0  0.66633204 0.20033243\n2  21194.35  1698.0390   2883336.3  2.09614479 0.08011754\n3  27755.09  4825.3960  23284446.3  0.64707878 0.17385627\n4  27142.60  4146.6643  17194824.5  1.16119871 0.15277327\n5  27681.99  4332.3440  18769204.5  0.92967739 0.15650406\n6  24249.16  3670.7229  13474206.9 -0.85466668 0.15137523\n7  59246.71 22419.9966 502656247.4 -0.62939642 0.37841757\n8  50685.94 16702.7409 278981554.2 -0.86488843 0.32953402\n9  69729.10 15306.7753 234297370.2 -0.84589675 0.21951775\n10 19740.12  8635.5046  74571939.8  1.07796143 0.43745947\n11 24375.01 22290.1025 496848668.9  1.18483157 0.91446544\n12 29322.23  5962.4104  35550337.5 -1.88571194 0.20334096\n13 23969.10  5043.2717  25434589.3  0.56523820 0.21040723\n14 25383.12 24258.0380 588452406.9  1.03964154 0.95567593\n15 21816.34  5040.3276  25404902.6  1.04816353 0.23103455\n16 36359.36 16102.9533 259305105.8  0.56214571 0.44288329\n17 42389.06 24307.7075 590864643.0 -0.32129825 0.57344291\n18 23672.87  2642.5387   6983010.8 -2.57545765 0.11162733\n19 27607.43  3389.1128  11486085.5  1.50576400 0.12276090\n20 22223.48  1889.3881   3569787.4  0.97182679 0.08501764\n21 24679.04  2679.7697   7181165.8 -1.15519704 0.10858485\n22 26558.82  7204.3387  51902495.6  0.01029577 0.27125975\n23 19778.52  2879.7720   8293087.0  1.11653676 0.14560101\n24 18458.67  5484.3159  30077721.1  1.62822457 0.29711324\n25 23423.43  7021.5422  49302054.4  0.03116617 0.29976582\n26 16541.26  2397.1846   5746493.9  0.60063497 0.14492156\n27 16545.42  3392.6269  11509917.5  0.06849616 0.20504933\n28 15066.82  4122.0062  16990935.1  3.08938061 0.27358169\n29 14821.56  3662.2795  13412290.8  0.44253465 0.24709131\n30 16915.67  2471.5922   6108768.0  0.72194074 0.14611257\n31 15183.78  3588.4893  12877255.6  2.94946079 0.23633700\n32 21541.65  5069.4678  25699503.7 -1.43147322 0.23533329\n33 19601.11  3108.9744   9665722.0  0.50522382 0.15861214\n34 32412.12 24242.1346 587681090.0  0.53522173 0.74793418\n35 20599.49  4617.7969  21324048.0  1.19120123 0.22417046\n36 28859.13 23348.8623 545169370.5  0.85575588 0.80906328\n37 11984.64  2493.0666   6215381.2  0.86286370 0.20802177\n38 17861.63  4667.0959  21781784.0 -0.94299674 0.26129176\n39 12911.26  2058.7063   4238271.6  0.57312479 0.15945051\n40 10313.11  1358.4328   1845339.8  1.46878192 0.13171898\n41 22146.45  4918.0988  24187695.5 -1.25740463 0.22207165\n42 14975.46  2055.6929   4225873.1 -1.70732382 0.13727074\n43 12164.44  1245.7923   1551998.4  1.22251626 0.10241262\n44 13193.61  3927.1815  15422754.5  1.39569677 0.29765777\n45 28443.02 24377.4421 594259684.0  0.77640738 0.85706245\n46 47125.62 15312.7089 234479054.1 -0.27861152 0.32493383\n47 38611.99 14830.2228 219935507.2  0.36610524 0.38408332\n48 17657.75  5844.9396  34163319.0  1.30857144 0.33101270\n49 17491.60  6505.9155  42326936.2  1.45654920 0.37194513\n50 15515.46  7517.4264  56511699.0  1.54877539 0.48451204\n51 20510.72  6286.3751  39518511.4  0.76211517 0.30649211\n52 26867.31  6659.8455  44353542.2 -0.81626138 0.24787916\n53 10537.76  1827.5034   3339768.6  1.73988753 0.17342427\n54 21458.65  6410.2129  41090829.2  0.92850266 0.29872402\n55 11158.95  2038.4420   4155245.7  0.87994007 0.18267325\n56 17755.28 12355.3608 152654940.8  3.44850457 0.69586971\n57 24456.63  3410.7395  11633143.6  0.67835216 0.13946070\n58 26336.34  4277.4598  18296661.9  0.62670078 0.16241662\n59 16996.88  1726.1703   2979664.0  0.32191512 0.10155806\n60 21694.07  5586.4342  31208247.3  0.41714732 0.25750971\n61 13001.25  1283.9048   1648411.5  5.98374890 0.09875244\n62 18465.25  3787.5902  14345839.6 -0.53021537 0.20511986\n63 18303.20  7692.6257  59176489.7  1.19968844 0.42028858\n64 26403.02  3950.9600  15610084.7 -0.16628639 0.14964046\n65 29483.86  5240.6913  27464845.8 -0.03662150 0.17774779\n66 39627.60  5939.7432  35280549.4  2.79485609 0.14988906\n67 31222.95 20177.8114 407144072.6  1.17435721 0.64624938\n68 38729.57 13251.8288 175610966.4  1.87097064 0.34216308\n69 21023.94  4320.0698  18663002.8  0.33292211 0.20548333\n70 21779.33  7897.1802  62365454.8  0.84949897 0.36259973\n71 36145.76  7572.2763  57339368.9  0.60666792 0.20949281\n72 18320.55  7250.8272  52574495.5  2.82295265 0.39577568\n73 32111.38  6803.2988  46284874.5 -0.78168385 0.21186567\n74 31241.75  6281.7162  39459957.9  1.01170224 0.20106800\n75 14149.53  3479.5527  12107287.0  0.61165691 0.24591292\n76 30094.68  5357.3059  28700726.8  1.43635637 0.17801508\n77 20612.58  1021.5081   1043478.9 -1.22827158 0.04955751\n78 28030.22 16659.8549 277550765.8  1.55786400 0.59435324\n79 11568.42  4599.1330  21152024.5  2.42445803 0.39755941\n80 30072.20 20122.3972 404910869.5  1.07612199 0.66913621\n81 20798.53  6099.8177  37207775.7  0.91816728 0.29328120\n82 20711.07  2402.3836   5771447.0  1.04546797 0.11599516\n83 31736.24  3995.0473  15960402.8 -3.74328455 0.12588280\n84 73545.30 17307.2896 299542274.1 -0.94731806 0.23532827\n85 22871.95  1329.5897   1767808.8  3.12696176 0.05813188\n86 32486.94 11032.8903 121724668.1  1.59450531 0.33961003\n87 17429.45  2571.4590   6612401.6 -0.50838795 0.14753533\n88 17096.49   926.3095    858049.3 -0.68882538 0.05418127"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html#overview",
    "href": "In-class_Ex/In-class_Ex04.html#overview",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "Spatial weights are a key component in any cross-sectional analysis of spatial dependence. They are an essential element in the construction of spatial autocorrelation statistics, and provide the means to create spatially explicit variables, such as spatially lagged variables and spatially smoothed rates. Computing spatial weight is an essential step toward measuring the strength of the spatial relationships between objects. In this exercise, the basic concept of spatial weight will be introduced. This is followed by a discussion of methods to compute spatial weights. Particularly, we will explore using spdep and GWmodel."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html#importing-packages",
    "href": "In-class_Ex/In-class_Ex04.html#importing-packages",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "In this hands-on exercise, we will use the following R package:\n\nsf\nsp\nspdep,\ntmap\ntidyverse\nknitr\nGWmodel\n\n\npacman::p_load(sf, sp, spdep, tmap, tidyverse, knitr, GWmodel)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html#importing-datasets-to-r-environment",
    "href": "In-class_Ex/In-class_Ex04.html#importing-datasets-to-r-environment",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "In this exercise, we will use the following datasets:\n\nHunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv This csv file contains selected Hunan’s local development indicators in 2012.\n\n\n\nIn this section, st_read() of sf package will be used to import the three geospatial data sets mentioned in previous section into R environment.\n\nhunan &lt;- st_read(dsn = \"../data/geospatial\", \n                 layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/khantminnaing/IS415-GAA/data/geospatial' using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\n\nIn this section, read_csv() of sf package will be used to import the csv file into R environment. The output is R dataframe class.\n\nhunan2012 &lt;- read_csv(\"../data/aspatial/Hunan_2012.csv\")\nhunan2012\n\n# A tibble: 88 × 29\n   County    City   avg_wage deposite    FAI Gov_Rev Gov_Exp    GDP GDPPC    GIO\n   &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 Anhua     Yiyang    30544   10967   6832.    457.   2703  13225  14567  9277.\n 2 Anren     Chenz…    28058    4599.  6386.    221.   1455.  4941. 12761  4189.\n 3 Anxiang   Chang…    31935    5517.  3541     244.   1780. 12482  23667  5109.\n 4 Baojing   Hunan…    30843    2250   1005.    193.   1379.  4088. 14563  3624.\n 5 Chaling   Zhuzh…    31251    8241.  6508.    620.   1947  11585  20078  9158.\n 6 Changning Hengy…    28518   10860   7920     770.   2632. 19886  24418 37392 \n 7 Changsha  Chang…    54540   24332  33624    5350    7886. 88009  88656 51361 \n 8 Chengbu   Shaoy…    28597    2581.  1922.    161.   1192.  2570. 10132  1681.\n 9 Chenxi    Huaih…    33580    4990   5818.    460.   1724.  7755. 17026  6644.\n10 Cili      Zhang…    33099    8117.  4498.    500.   2306. 11378  18714  5843.\n# ℹ 78 more rows\n# ℹ 19 more variables: Loan &lt;dbl&gt;, NIPCR &lt;dbl&gt;, Bed &lt;dbl&gt;, Emp &lt;dbl&gt;,\n#   EmpR &lt;dbl&gt;, EmpRT &lt;dbl&gt;, Pri_Stu &lt;dbl&gt;, Sec_Stu &lt;dbl&gt;, Household &lt;dbl&gt;,\n#   Household_R &lt;dbl&gt;, NOIP &lt;dbl&gt;, Pop_R &lt;dbl&gt;, RSCG &lt;dbl&gt;, Pop_T &lt;dbl&gt;,\n#   Agri &lt;dbl&gt;, Service &lt;dbl&gt;, Disp_Inc &lt;dbl&gt;, RORP &lt;dbl&gt;, ROREmp &lt;dbl&gt;"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html#geospatial-data-wrangling",
    "href": "In-class_Ex/In-class_Ex04.html#geospatial-data-wrangling",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "In previous section, we have imported a shapefile hunan representing the geographical boundaries of Hunan and a dataframe hunan2012 which contains the attribute fields corresponding to counties in Hunan.\nThe next step in our analysis involves updating the attribute table of the hunan shapefile with the values from hunan2012.\nHence, we will need to update the attribute table of Hunan by using left_join() of dplyr package. This function effectively merges the two datasets, ensuring that each county’s geographical data is accurately linked with its corresponding attribute data from the hunan2012 dataframe.\n\nhunan &lt;- left_join(hunan,hunan2012, join_by(County))%&gt;%\n  select(1:4, 7, 15)\n\n\n\n\n\nhunan_sp &lt;- hunan %&gt;% as_Spatial()"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex04.html#geographically-weighted-summary-statistics-gwss",
    "href": "In-class_Ex/In-class_Ex04.html#geographically-weighted-summary-statistics-gwss",
    "title": "In-Class Exercise 04",
    "section": "",
    "text": "This function calculates basic and robust GWSS, including geographically weighted means, standard deviations and skew. Robust alternatives include geographically weighted medians, inter-quartile ranges and quantile imbalances. This function also calculates basic geographically weighted covariances together with basic and robust geographically weighted correlations.\n\ngwstat &lt;- gwss(data= hunan_sp,\n               vars = \"GDPPC\",\n               bw = 6,\n               kernel = \"bisquare\",\n               adaptive = TRUE,\n               longlat = T)\n\nWhat can we learn from this code chunk?\n\nThe data argument is set to hunan_sp, which means the data being used is stored in the hunan_sp variable.\nThe vars argument is set to \"GDPPC\". This indicates that the variable of interest in the hunan_sp data is \"GDPPC\".\nThe bw argument is set to 6. This is the bandwidth parameter for the geographical weighting, which controls the degree of smoothing.\nThe kernel argument is set to \"bisquare\". This means the bisquare kernel function is used for weighting.\nThe adaptive argument is set to TRUE, which means the bandwidth is adaptive. In other words, the bandwidth adjusts depending on the density of the data points.\nThe longlat argument is set to T (short for TRUE). This indicates that the data’s coordinates are in longitude and latitude.\n\n\ngwstat\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n\n   ***********************Calibration information*************************\n\n   Local summary statistics calculated for variables:\n    GDPPC\n   Number of summary points: 88\n   Kernel function: bisquare \n   Summary points: the same locations as observations are used.\n   Adaptive bandwidth: 6 (number of nearest neighbours)\n   Distance metric: Great Circle distance metric is used.\n\n   ************************Local Summary Statistics:**********************\n   Summary information for Local means:\nGDPPC_LM \n    Min.  1st Qu.   Median  3rd Qu.     Max. \n10313.11 17616.21 21981.39 28547.05 73545.30 \n   Summary information for local standard deviation :\nGDPPC_LSD \n      Min.    1st Qu.     Median    3rd Qu.       Max. \n  926.3095  3319.0782  5041.7997  7602.3637 24377.4421 \n   Summary information for local variance :\nGDPPC_LVar \n       Min.     1st Qu.      Median     3rd Qu.        Max. \n   858049.3  11030994.6  25419746.0  57798649.1 594259684.0 \n   Summary information for Local skewness:\nGDPPC_LSKe \n       Min.     1st Qu.      Median     3rd Qu.        Max. \n-3.74328455 -0.06903772  0.74202796  1.20539540  5.98374890 \n   Summary information for localized coefficient of variation:\nGDPPC_LCV \n      Min.    1st Qu.     Median    3rd Qu.       Max. \n0.04955751 0.15100369 0.22079470 0.33316203 0.95567593 \n\n   ************************************************************************\n\n\nThe output of the gwss() function is a SpatialPointsDataFrame (SDF). We can view the values inside this dataframe.\n\ngwstat_df &lt;- gwstat[[\"SDF\"]]@data\ngwstat_df\n\n   GDPPC_LM  GDPPC_LSD  GDPPC_LVar  GDPPC_LSKe  GDPPC_LCV\n1  26797.76  5368.4595  28820357.0  0.66633204 0.20033243\n2  21194.35  1698.0390   2883336.3  2.09614479 0.08011754\n3  27755.09  4825.3960  23284446.3  0.64707878 0.17385627\n4  27142.60  4146.6643  17194824.5  1.16119871 0.15277327\n5  27681.99  4332.3440  18769204.5  0.92967739 0.15650406\n6  24249.16  3670.7229  13474206.9 -0.85466668 0.15137523\n7  59246.71 22419.9966 502656247.4 -0.62939642 0.37841757\n8  50685.94 16702.7409 278981554.2 -0.86488843 0.32953402\n9  69729.10 15306.7753 234297370.2 -0.84589675 0.21951775\n10 19740.12  8635.5046  74571939.8  1.07796143 0.43745947\n11 24375.01 22290.1025 496848668.9  1.18483157 0.91446544\n12 29322.23  5962.4104  35550337.5 -1.88571194 0.20334096\n13 23969.10  5043.2717  25434589.3  0.56523820 0.21040723\n14 25383.12 24258.0380 588452406.9  1.03964154 0.95567593\n15 21816.34  5040.3276  25404902.6  1.04816353 0.23103455\n16 36359.36 16102.9533 259305105.8  0.56214571 0.44288329\n17 42389.06 24307.7075 590864643.0 -0.32129825 0.57344291\n18 23672.87  2642.5387   6983010.8 -2.57545765 0.11162733\n19 27607.43  3389.1128  11486085.5  1.50576400 0.12276090\n20 22223.48  1889.3881   3569787.4  0.97182679 0.08501764\n21 24679.04  2679.7697   7181165.8 -1.15519704 0.10858485\n22 26558.82  7204.3387  51902495.6  0.01029577 0.27125975\n23 19778.52  2879.7720   8293087.0  1.11653676 0.14560101\n24 18458.67  5484.3159  30077721.1  1.62822457 0.29711324\n25 23423.43  7021.5422  49302054.4  0.03116617 0.29976582\n26 16541.26  2397.1846   5746493.9  0.60063497 0.14492156\n27 16545.42  3392.6269  11509917.5  0.06849616 0.20504933\n28 15066.82  4122.0062  16990935.1  3.08938061 0.27358169\n29 14821.56  3662.2795  13412290.8  0.44253465 0.24709131\n30 16915.67  2471.5922   6108768.0  0.72194074 0.14611257\n31 15183.78  3588.4893  12877255.6  2.94946079 0.23633700\n32 21541.65  5069.4678  25699503.7 -1.43147322 0.23533329\n33 19601.11  3108.9744   9665722.0  0.50522382 0.15861214\n34 32412.12 24242.1346 587681090.0  0.53522173 0.74793418\n35 20599.49  4617.7969  21324048.0  1.19120123 0.22417046\n36 28859.13 23348.8623 545169370.5  0.85575588 0.80906328\n37 11984.64  2493.0666   6215381.2  0.86286370 0.20802177\n38 17861.63  4667.0959  21781784.0 -0.94299674 0.26129176\n39 12911.26  2058.7063   4238271.6  0.57312479 0.15945051\n40 10313.11  1358.4328   1845339.8  1.46878192 0.13171898\n41 22146.45  4918.0988  24187695.5 -1.25740463 0.22207165\n42 14975.46  2055.6929   4225873.1 -1.70732382 0.13727074\n43 12164.44  1245.7923   1551998.4  1.22251626 0.10241262\n44 13193.61  3927.1815  15422754.5  1.39569677 0.29765777\n45 28443.02 24377.4421 594259684.0  0.77640738 0.85706245\n46 47125.62 15312.7089 234479054.1 -0.27861152 0.32493383\n47 38611.99 14830.2228 219935507.2  0.36610524 0.38408332\n48 17657.75  5844.9396  34163319.0  1.30857144 0.33101270\n49 17491.60  6505.9155  42326936.2  1.45654920 0.37194513\n50 15515.46  7517.4264  56511699.0  1.54877539 0.48451204\n51 20510.72  6286.3751  39518511.4  0.76211517 0.30649211\n52 26867.31  6659.8455  44353542.2 -0.81626138 0.24787916\n53 10537.76  1827.5034   3339768.6  1.73988753 0.17342427\n54 21458.65  6410.2129  41090829.2  0.92850266 0.29872402\n55 11158.95  2038.4420   4155245.7  0.87994007 0.18267325\n56 17755.28 12355.3608 152654940.8  3.44850457 0.69586971\n57 24456.63  3410.7395  11633143.6  0.67835216 0.13946070\n58 26336.34  4277.4598  18296661.9  0.62670078 0.16241662\n59 16996.88  1726.1703   2979664.0  0.32191512 0.10155806\n60 21694.07  5586.4342  31208247.3  0.41714732 0.25750971\n61 13001.25  1283.9048   1648411.5  5.98374890 0.09875244\n62 18465.25  3787.5902  14345839.6 -0.53021537 0.20511986\n63 18303.20  7692.6257  59176489.7  1.19968844 0.42028858\n64 26403.02  3950.9600  15610084.7 -0.16628639 0.14964046\n65 29483.86  5240.6913  27464845.8 -0.03662150 0.17774779\n66 39627.60  5939.7432  35280549.4  2.79485609 0.14988906\n67 31222.95 20177.8114 407144072.6  1.17435721 0.64624938\n68 38729.57 13251.8288 175610966.4  1.87097064 0.34216308\n69 21023.94  4320.0698  18663002.8  0.33292211 0.20548333\n70 21779.33  7897.1802  62365454.8  0.84949897 0.36259973\n71 36145.76  7572.2763  57339368.9  0.60666792 0.20949281\n72 18320.55  7250.8272  52574495.5  2.82295265 0.39577568\n73 32111.38  6803.2988  46284874.5 -0.78168385 0.21186567\n74 31241.75  6281.7162  39459957.9  1.01170224 0.20106800\n75 14149.53  3479.5527  12107287.0  0.61165691 0.24591292\n76 30094.68  5357.3059  28700726.8  1.43635637 0.17801508\n77 20612.58  1021.5081   1043478.9 -1.22827158 0.04955751\n78 28030.22 16659.8549 277550765.8  1.55786400 0.59435324\n79 11568.42  4599.1330  21152024.5  2.42445803 0.39755941\n80 30072.20 20122.3972 404910869.5  1.07612199 0.66913621\n81 20798.53  6099.8177  37207775.7  0.91816728 0.29328120\n82 20711.07  2402.3836   5771447.0  1.04546797 0.11599516\n83 31736.24  3995.0473  15960402.8 -3.74328455 0.12588280\n84 73545.30 17307.2896 299542274.1 -0.94731806 0.23532827\n85 22871.95  1329.5897   1767808.8  3.12696176 0.05813188\n86 32486.94 11032.8903 121724668.1  1.59450531 0.33961003\n87 17429.45  2571.4590   6612401.6 -0.50838795 0.14753533\n88 17096.49   926.3095    858049.3 -0.68882538 0.05418127\n\n\nGDPPC_LM refers to local means\nGDPPC_LSD refers to local standard deviation\nGDPPC_LVar refers to local variance\nGDPPC_LSKe refers to local skew\nGDPPC_LCV refers to local coefficients of variation\n\n\n\ngwstat_df\n\n   GDPPC_LM  GDPPC_LSD  GDPPC_LVar  GDPPC_LSKe  GDPPC_LCV\n1  26797.76  5368.4595  28820357.0  0.66633204 0.20033243\n2  21194.35  1698.0390   2883336.3  2.09614479 0.08011754\n3  27755.09  4825.3960  23284446.3  0.64707878 0.17385627\n4  27142.60  4146.6643  17194824.5  1.16119871 0.15277327\n5  27681.99  4332.3440  18769204.5  0.92967739 0.15650406\n6  24249.16  3670.7229  13474206.9 -0.85466668 0.15137523\n7  59246.71 22419.9966 502656247.4 -0.62939642 0.37841757\n8  50685.94 16702.7409 278981554.2 -0.86488843 0.32953402\n9  69729.10 15306.7753 234297370.2 -0.84589675 0.21951775\n10 19740.12  8635.5046  74571939.8  1.07796143 0.43745947\n11 24375.01 22290.1025 496848668.9  1.18483157 0.91446544\n12 29322.23  5962.4104  35550337.5 -1.88571194 0.20334096\n13 23969.10  5043.2717  25434589.3  0.56523820 0.21040723\n14 25383.12 24258.0380 588452406.9  1.03964154 0.95567593\n15 21816.34  5040.3276  25404902.6  1.04816353 0.23103455\n16 36359.36 16102.9533 259305105.8  0.56214571 0.44288329\n17 42389.06 24307.7075 590864643.0 -0.32129825 0.57344291\n18 23672.87  2642.5387   6983010.8 -2.57545765 0.11162733\n19 27607.43  3389.1128  11486085.5  1.50576400 0.12276090\n20 22223.48  1889.3881   3569787.4  0.97182679 0.08501764\n21 24679.04  2679.7697   7181165.8 -1.15519704 0.10858485\n22 26558.82  7204.3387  51902495.6  0.01029577 0.27125975\n23 19778.52  2879.7720   8293087.0  1.11653676 0.14560101\n24 18458.67  5484.3159  30077721.1  1.62822457 0.29711324\n25 23423.43  7021.5422  49302054.4  0.03116617 0.29976582\n26 16541.26  2397.1846   5746493.9  0.60063497 0.14492156\n27 16545.42  3392.6269  11509917.5  0.06849616 0.20504933\n28 15066.82  4122.0062  16990935.1  3.08938061 0.27358169\n29 14821.56  3662.2795  13412290.8  0.44253465 0.24709131\n30 16915.67  2471.5922   6108768.0  0.72194074 0.14611257\n31 15183.78  3588.4893  12877255.6  2.94946079 0.23633700\n32 21541.65  5069.4678  25699503.7 -1.43147322 0.23533329\n33 19601.11  3108.9744   9665722.0  0.50522382 0.15861214\n34 32412.12 24242.1346 587681090.0  0.53522173 0.74793418\n35 20599.49  4617.7969  21324048.0  1.19120123 0.22417046\n36 28859.13 23348.8623 545169370.5  0.85575588 0.80906328\n37 11984.64  2493.0666   6215381.2  0.86286370 0.20802177\n38 17861.63  4667.0959  21781784.0 -0.94299674 0.26129176\n39 12911.26  2058.7063   4238271.6  0.57312479 0.15945051\n40 10313.11  1358.4328   1845339.8  1.46878192 0.13171898\n41 22146.45  4918.0988  24187695.5 -1.25740463 0.22207165\n42 14975.46  2055.6929   4225873.1 -1.70732382 0.13727074\n43 12164.44  1245.7923   1551998.4  1.22251626 0.10241262\n44 13193.61  3927.1815  15422754.5  1.39569677 0.29765777\n45 28443.02 24377.4421 594259684.0  0.77640738 0.85706245\n46 47125.62 15312.7089 234479054.1 -0.27861152 0.32493383\n47 38611.99 14830.2228 219935507.2  0.36610524 0.38408332\n48 17657.75  5844.9396  34163319.0  1.30857144 0.33101270\n49 17491.60  6505.9155  42326936.2  1.45654920 0.37194513\n50 15515.46  7517.4264  56511699.0  1.54877539 0.48451204\n51 20510.72  6286.3751  39518511.4  0.76211517 0.30649211\n52 26867.31  6659.8455  44353542.2 -0.81626138 0.24787916\n53 10537.76  1827.5034   3339768.6  1.73988753 0.17342427\n54 21458.65  6410.2129  41090829.2  0.92850266 0.29872402\n55 11158.95  2038.4420   4155245.7  0.87994007 0.18267325\n56 17755.28 12355.3608 152654940.8  3.44850457 0.69586971\n57 24456.63  3410.7395  11633143.6  0.67835216 0.13946070\n58 26336.34  4277.4598  18296661.9  0.62670078 0.16241662\n59 16996.88  1726.1703   2979664.0  0.32191512 0.10155806\n60 21694.07  5586.4342  31208247.3  0.41714732 0.25750971\n61 13001.25  1283.9048   1648411.5  5.98374890 0.09875244\n62 18465.25  3787.5902  14345839.6 -0.53021537 0.20511986\n63 18303.20  7692.6257  59176489.7  1.19968844 0.42028858\n64 26403.02  3950.9600  15610084.7 -0.16628639 0.14964046\n65 29483.86  5240.6913  27464845.8 -0.03662150 0.17774779\n66 39627.60  5939.7432  35280549.4  2.79485609 0.14988906\n67 31222.95 20177.8114 407144072.6  1.17435721 0.64624938\n68 38729.57 13251.8288 175610966.4  1.87097064 0.34216308\n69 21023.94  4320.0698  18663002.8  0.33292211 0.20548333\n70 21779.33  7897.1802  62365454.8  0.84949897 0.36259973\n71 36145.76  7572.2763  57339368.9  0.60666792 0.20949281\n72 18320.55  7250.8272  52574495.5  2.82295265 0.39577568\n73 32111.38  6803.2988  46284874.5 -0.78168385 0.21186567\n74 31241.75  6281.7162  39459957.9  1.01170224 0.20106800\n75 14149.53  3479.5527  12107287.0  0.61165691 0.24591292\n76 30094.68  5357.3059  28700726.8  1.43635637 0.17801508\n77 20612.58  1021.5081   1043478.9 -1.22827158 0.04955751\n78 28030.22 16659.8549 277550765.8  1.55786400 0.59435324\n79 11568.42  4599.1330  21152024.5  2.42445803 0.39755941\n80 30072.20 20122.3972 404910869.5  1.07612199 0.66913621\n81 20798.53  6099.8177  37207775.7  0.91816728 0.29328120\n82 20711.07  2402.3836   5771447.0  1.04546797 0.11599516\n83 31736.24  3995.0473  15960402.8 -3.74328455 0.12588280\n84 73545.30 17307.2896 299542274.1 -0.94731806 0.23532827\n85 22871.95  1329.5897   1767808.8  3.12696176 0.05813188\n86 32486.94 11032.8903 121724668.1  1.59450531 0.33961003\n87 17429.45  2571.4590   6612401.6 -0.50838795 0.14753533\n88 17096.49   926.3095    858049.3 -0.68882538 0.05418127"
  }
]